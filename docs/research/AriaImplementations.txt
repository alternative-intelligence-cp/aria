/* ==========================================================================
   MODULE: BACKEND / TERNARY LOGIC LOWERING
   FILE: src/backend/lowering_ternary.cpp
   ========================================================================== */
#include <immintrin.h>

// Lowers a ternary add using AVX-512 VPTERNLOGD
// Arguments:
//   out_ptr: Pointer to destination memory (64-byte aligned)
//   a_ptr:   Pointer to first source operand (64-byte aligned)
//   b_ptr:   Pointer to second source operand (64-byte aligned)
void emit_ternary_add_avx512(void* out_ptr, void* a_ptr, void* b_ptr) {
   // Load 256 packed trits (512 bits) from memory into ZMM registers
   // Note: We use _mm512_load_si512 which requires 64-byte alignment.
   __m512i a = _mm512_load_si512((__m512i*)a_ptr);
   __m512i b = _mm512_load_si512((__m512i*)b_ptr);

   // Truth table for Balanced Ternary Sum (Low Bit)
   // The immediate value 0x96 represents the specific Karnaugh map 
   // for (A XOR B) logic adjusted for ternary encoding (00=0, 01=1, 10=-1).
   // _mm512_ternarylogic_epi32 computes (A op B op C) per bit.
   // We reuse 'a' as the 3rd input since the logic is binary, but the 
   // immediate value 0x96 only depends on the first two inputs in this mapping.
   // Logic: (A ^ B)
   __m512i sum_lo = _mm512_ternarylogic_epi32(a, b, a, 0x96);

   // Truth table for Balanced Ternary Sum (High Bit)
   // 0xE8 is the calculated truth table for the high bit (carry-like behavior)
   // required to represent the ternary result correctly in packed format.
   // This handles the overflow case where 1 + 1 = -1 (logic high).
   __m512i sum_hi = _mm512_ternarylogic_epi32(a, b, a, 0xE8);

   // Combine and store
   // In a full implementation, 'sum_lo' and 'sum_hi' would be interleaved 
   // or masked back into the storage format.
   // For this reference, we store the low bits as the primary result.
   _mm512_store_si512((__m512i*)out_ptr, sum_lo);
}

/* ==========================================================================
   MODULE: STANDARD LIBRARY / MATH
   FILE: src/stdlib/math/ternary.aria
   ========================================================================== */
// Standard Library Module for Exotic Logic Arithmetic
// This file implements the high-level wrappers for the AVX-512 intrinsics.
mod std.math.ternary {
   
   // Explicit visibility export
   pub type Trit = trit;
   pub type Tryte = tryte;

   // Determines the "unknown" state of a balanced ternary value
   // In balanced ternary, 0 is often treated as 'unknown' or 'maybe' in logic contexts
   pub func:is_unknown = (trit:t) -> bool {
       return t == 0;
   };

   // Logical consensus function
   // Returns 1 if majority are 1, -1 if majority -1, else 0
   pub func:consensus = (trit[]:votes) -> trit {
       wild int64:sum = 0;
       // Use 'till' loop with implicit iterator '$'
       till(votes.len, 1) {
           // Accessing votes via safe index
           // In a real implementation, this would use SIMD reduction
           sum += votes[$];
       }

       // Return balanced result
       if (sum > 0) { return 1; }
       else if (sum < 0) { return -1; }
       else { return 0; }
   };

   // Low-level intrinsic binding for vector addition
   // The compiler maps this to the 'emit_ternary_add_avx512' C++ backend function
   extern "internal" {
       func:__vec_add_trits(trit@:dest, trit@:src_a, trit@:src_b, int64:len) -> void;
   }

   // Safe wrapper for vector addition
   pub func:add_vectors = (trit[]:a, trit[]:b) -> result<trit[]> {
       if (a.len != b.len) {
           return { val: NULL, err: "Vector length mismatch" };
       }

       // Allocate result in GC memory
       trit[]:res = aria.alloc_array<trit>(a.len);

       // Pin memory to ensure the GC doesn't move it during the extern call
       // This demonstrates the safety bridge: we pin the managed arrays
       // so the wild pointer arithmetic in the C++ backend is safe.
       wild trit[]:p_res = #res;
       wild trit[]:p_a   = #a;
       wild trit[]:p_b   = #b;

       // Perform hardware accelerated add
       // The '@' operator retrieves the raw memory address of the pinned variable
       __vec_add_trits(@p_res, @p_a, @p_b, a.len);

       return { val: res, err: NULL };
   };
}

/* ==========================================================================
   MODULE: RUNTIME / TYPES
   FILE: src/runtime/types/tensor.h
   ========================================================================== */
#include <cstdint>

// Descriptor struct for the 'tensor' type
struct Tensor {
   void* data;          // Pointer to data payload (Managed or Wild)
   uint64_t* shape;     // Array of dimension sizes
   uint64_t* strides;   // Array of memory steps for indexing optimization
   uint8_t dtype;       // Element type enum (e.g., INT8, FLT32, TRIT)
   uint8_t rank;        // Number of dimensions (e.g., 2 for matrix)
   uint8_t padding;     // Explicit padding to ensure 64-bit struct alignment
};

/* ==========================================================================
   MODULE: RUNTIME / GARBAGE COLLECTION
   FILE: src/runtime/gc/nursery.cpp
   ========================================================================== */
// Implementation of the Fragmented Nursery Allocator
#include <cstdint>
#include <cstddef>
#include "gc_impl.h"

// Represents a free contiguous region in the Nursery
struct FreeFragment {
   uint8_t* start;
   uint8_t* end;
   FreeFragment* next;
};

// Thread-Local Nursery Context
struct Nursery {
   uint8_t* start_addr;
   uint8_t* end_addr;
   uint8_t* bump_ptr;   // Current allocation head
   FreeFragment* fragments; // Linked list of free regions (if fragmented)
   
   // Config
   size_t size;
};

// Global config
const size_t NURSERY_SIZE = 4 * 1024 * 1024; // 4MB

// The core allocation routine (Hot Path)
extern "C" void* aria_gc_alloc(Nursery* nursery, size_t size) {
   // 1. Fast Path: Standard Bump Allocation
   // Check if we fit in the current fragment or main buffer
   uint8_t* new_bump = nursery->bump_ptr + size;

   // Check against the end of the current active region (fragment or main)
   if (new_bump <= nursery->end_addr) {
       void* ptr = nursery->bump_ptr;
       nursery->bump_ptr = new_bump;
       return ptr;
   }

   // 2. Slow Path: Fragment Search or Collection Trigger
   // If we are in fragmented mode (fragments list is not null), try next fragment
   if (nursery->fragments) {
       FreeFragment* prev = nullptr;
       FreeFragment* curr = nursery->fragments;
       
       while (curr) {
           size_t frag_size = curr->end - curr->start;
           if (frag_size >= size) {
               // Found a fit!
               void* ptr = curr->start;
               
               // Update fragment
               curr->start += size;

               // If fragment is exhausted, remove it
               if (curr->start == curr->end) {
                   if (prev) prev->next = curr->next;
                   else nursery->fragments = curr->next;
               }
               
               return ptr;
           }
           prev = curr;
           curr = curr->next;
       }
   }

   // 3. Collection Path: Nursery is truly full
   // Trigger Minor GC. This function will:
   // a) Evacuate unpinned objects to Old Gen
   // b) Identify pinned objects remaining in Nursery
   // c) Rebuild 'nursery->fragments' list with holes between pins
   // d) Reset bump_ptr to first fragment
   aria_gc_collect_minor();

   // Retry allocation after collection
   return aria_gc_alloc(nursery, size);
}

/* ==========================================================================
   MODULE: RUNTIME / GARBAGE COLLECTION
   FILE: src/runtime/gc/gc_impl.cpp
   ========================================================================== */
// Implementation of the Major and Minor Garbage Collection Logic
#include "gc_impl.h"
#include "header.h"
#include <vector>
#include <stack>
#include <cstdlib>
#include <cstring>

// Global List of Old Generation Objects
// In a production system, this would be a paged block allocator.
// For reference, we use a simple vector of pointers.
std::vector<ObjHeader*> old_gen_objects;

// Mock function to retrieve roots from the stack and registers.
// In reality, this requires intricate stack frame walking (e.g., libunwind).
extern std::vector<void*> get_thread_roots();

// Helper: Mark an object and its children (DFS)
void mark_object(ObjHeader* obj) {
   if (!obj || obj->mark_bit) return;

   // 1. Mark Self
   obj->mark_bit = 1;

   // 2. Scan Children
   // Aria uses RTTI (type_id) to know where pointers live in the payload.
   // This switch acts as the "Visitor" pattern.
   switch (obj->type_id) {
       case TYPE_ARRAY_OBJ: {
           // Array of Objects: Scan all elements
           void** data = (void**)((char*)obj + sizeof(ObjHeader));
           size_t count = obj->size_class; // Simplified size handling
           for (size_t i = 0; i < count; i++) {
               if (data[i]) mark_object((ObjHeader*)((char*)data[i] - sizeof(ObjHeader)));
           }
           break;
       }
       case TYPE_STRUCT: {
           // Struct: Use compile-time generated descriptor to find pointers
           // Implementation omitted for brevity
           break;
       }
       // Primitives (INT, TRIT) have no children to mark.
       default: break;
   }
}

// Phase 1: Minor Collection (Nursery Evacuation)
// This function moves non-pinned objects out of the nursery to the old generation.
void aria_gc_collect_minor() {
   // 1. Get Roots
   auto roots = get_thread_roots();

   // 2. Evacuate Survivors
   for (void* root_ptr : roots) {
       if (!root_ptr) continue;
       ObjHeader* obj = (ObjHeader*)((char*)root_ptr - sizeof(ObjHeader));
       
       // If object is in Nursery...
       if (obj->is_nursery) {
           if (obj->pinned_bit) {
               // Pinned: Cannot move. Mark as preserved.
               // The nursery reset logic will skip this memory block.
           } else {
               // Not Pinned: Move to Old Gen
               // a. Alloc in Old Gen
               ObjHeader* new_loc = (ObjHeader*)malloc(obj->size_class);
               memcpy(new_loc, obj, obj->size_class);
               
               // b. Update Header
               new_loc->is_nursery = 0;
               new_loc->pinned_bit = 0; // Pinning applies to nursery location usually
               
               // c. Forwarding Pointer (broken heart) logic would go here
               // to update other references to this object.
               // In a moving collector, we leave a forwarding address in the old location.
               
               old_gen_objects.push_back(new_loc);
           }
       }
   }
   
   // 3. Rebuild Fragments (Simplified)
   // The nursery bump pointer is reset, but we must construct the free list
   // to skip over the pinned objects identified in step 2.
}

// Phase 2: Major Collection (Mark-Sweep)
// This function reclaims memory from the Old Generation.
void aria_gc_collect_major() {
   // 1. Mark Phase
   auto roots = get_thread_roots();
   for (void* root : roots) {
       if (root) mark_object((ObjHeader*)((char*)root - sizeof(ObjHeader)));
   }

   // 2. Sweep Phase
   auto it = old_gen_objects.begin();
   while (it != old_gen_objects.end()) {
       ObjHeader* obj = *it;
       if (obj->mark_bit) {
           // Live: Reset mark bit for next cycle
           obj->mark_bit = 0;
           ++it;
       } else {
           // Dead: Reclaim memory
           free(obj);

           // Constant-time swap-remove
           *it = old_gen_objects.back();
           old_gen_objects.pop_back();
           // Don't increment iterator, verify swapped element next
       }
   }
}

/* ==========================================================================
   MODULE: RUNTIME / MEMORY
   FILE: src/runtime/memory/allocator.c
   ========================================================================== */
#include <mimalloc.h>
#include <stddef.h>

// Runtime Interface for Wild Allocations
// These functions are linked directly to the 'aria.alloc' and 'aria.free' intrinsics.
// Note: We use extern "C" to prevent name mangling, allowing LLVM to link easily.
extern "C" {
   // Basic allocation mapping
   void* aria_alloc(size_t size) { 
       // mi_malloc provides thread-local, lock-free allocation
       // Utilizing the 'mimalloc' backend ensures cache-locality and minimizes fragmentation.
       return mi_malloc(size);
   }
   
   // Explicit deallocation
   void aria_free(void* ptr) { 
       // mi_free handles return to the correct thread segment
       // If the pointer was allocated on a different thread, mimalloc handles the atomic
       // handoff to the owning heap lazily.
       mi_free(ptr);
   }
   
   // Reallocation
   void* aria_realloc(void* ptr, size_t size) { 
       return mi_realloc(ptr, size);
   }
   
   // Aligned allocation for SIMD types (vec9, tensor)
   // Ensures pointers respect the 64-byte alignment required by AVX-512 ZMM registers
   void* aria_alloc_aligned(size_t size, size_t alignment) {
       return mi_malloc_aligned(size, alignment);
   }
}

/* ==========================================================================
   MODULE: RUNTIME / GC HEADER
   FILE: src/runtime/gc/header.h
   ========================================================================== */
#include <cstdint>

struct ObjHeader {
   // Bitfields for compact storage overhead (8 bytes total)
   uint64_t mark_bit : 1;      // Used by Mark-and-Sweep algorithm
   uint64_t pinned_bit : 1;    // The '#' Pinning Flag. If 1, GC skips moving this.
   uint64_t forwarded_bit : 1; // Used during Copying phase to track relocation
   uint64_t is_nursery : 1;    // Generation flag (0=Old, 1=Nursery)
   uint64_t size_class : 8;    // Allocator size bucket index
   uint64_t type_id : 16;      // RTTI / Type information for 'dyn' and pattern matching
   uint64_t padding : 36;      // Reserved for future use (e.g., hash code cache)
};

/* ==========================================================================
   MODULE: FRONTEND / PARSER (PICK)
   FILE: src/frontend/parser_pick.cpp
   ========================================================================== */
// Implementation of the 'pick' statement parser
// Handles: pick(val) { (<9) { ... }, success:(!) { ... } }
#include "parser.h"
#include "ast/control_flow.h"
#include <memory>

std::unique_ptr<PickStmt> Parser::parsePickStmt() {
   consume(TOKEN_PICK, "Expected 'pick'");
   consume(TOKEN_LEFT_PAREN, "Expected '(' after 'pick'");
   
   auto stmt = std::make_unique<PickStmt>();
   stmt->selector = parseExpression();
   
   consume(TOKEN_RIGHT_PAREN, "Expected ')'");
   consume(TOKEN_LEFT_BRACE, "Expected '{' to begin pick body");

   // Parse Cases
   while (!check(TOKEN_RIGHT_BRACE) && !check(TOKEN_EOF)) {
       PickCase pcase;
       
       // 1. Detect Match Type
       if (match(TOKEN_LEFT_PAREN)) {
           // Value or Range Match: (9), (<9), (>9), (*)
           if (match(TOKEN_LESS_THAN)) {
               pcase.type = PickCase::RANGE;
               pcase.value_end = parseExpression(); // Upper bound
               // Implicitly implies -Infinity to value_end
           } 
           else if (match(TOKEN_GREATER_THAN)) {
               pcase.type = PickCase::RANGE;
               pcase.value_start = parseExpression(); // Lower bound
           }
           else if (match(TOKEN_MULTIPLY)) { // '*' is wildcard
               pcase.type = PickCase::WILDCARD;
           }
           else {
               // Exact match
               pcase.type = PickCase::EXACT;
               pcase.value_start = parseExpression();
           }
           consume(TOKEN_RIGHT_PAREN, "Expected ')' after case condition");
       } 
       else if (check(TOKEN_IDENTIFIER)) {
           // Label match: success:(!)
           Token label = advance();
           pcase.label = label.lexeme;
           consume(TOKEN_COLON, "Expected ':' after label");
           consume(TOKEN_LEFT_PAREN, "Expected '('");
           consume(TOKEN_LOGICAL_NOT, "Expected '!' in label definition");
           consume(TOKEN_RIGHT_PAREN, "Expected ')'");
           pcase.type = PickCase::EXACT; // Logically treated as jump target
       }

       // 2. Parse Body
       consume(TOKEN_LEFT_BRACE, "Expected '{' for case body");
       pcase.body = parseBlock(); 
       // Note: parseBlock consumes the closing brace '}'

       // 3. Register Label mapping for CFG
       if (!pcase.label.empty()) {
           stmt->label_map[pcase.label] = stmt->cases.size();
       }

       stmt->cases.push_back(std::move(pcase));
       
       // Optional comma between cases
       match(TOKEN_COMMA);
   }

   consume(TOKEN_RIGHT_BRACE, "Expected '}' to end pick statement");
   return stmt;
}

/* ==========================================================================
   MODULE: FRONTEND / AST
   FILE: src/frontend/ast/loops.h
   ========================================================================== */
// New file implementation for loop constructs

struct LoopStmt : public AstNode {
   std::unique_ptr<Block> body;
   // ...
};

struct TillLoop : public LoopStmt {
   std::unique_ptr<Expr> limit;
   std::unique_ptr<Expr> step;

   // The implicit iterator variable declaration
   // This is created during the parsing phase, not by the user.
   // It is marked as 'implicit' to prevent user redeclaration errors.
   std::unique_ptr<VarDecl> implicit_iterator;

   TillLoop(std::unique_ptr<Expr> l, std::unique_ptr<Expr> s) 
       : limit(std::move(l)), step(std::move(s)) {
       // Construct the implicit '$' variable
       implicit_iterator = std::make_unique<VarDecl>("$", TYPE_INT64, true);
   }
};

/* ==========================================================================
   MODULE: FRONTEND / LEXER
   FILE: src/frontend/lexer.cpp
   ========================================================================== */
#include <stack>
#include <string>
#include <map>
#include <vector>
#include "tokens.h" // Includes the complete token list defined in Section 9

enum LexerState { STATE_ROOT, STATE_STRING_TEMPLATE, STATE_INTERPOLATION };

class AriaLexer {
private:
   std::string source;
   size_t pos = 0;
   size_t line = 1, col = 1;
   std::stack<LexerState> stateStack;

   char peek() { return pos < source.length() ? source[pos] : 0; }
   char peekNext() { return pos + 1 < source.length() ? source[pos + 1] : 0; }
   
   void advance() { 
       if (peek() == '\n') { line++; col=1; } else { col++; } 
       pos++;
   }

   // Helper to parse identifier for sanitization check
   std::string parseIdentifier() {
       size_t start = pos;
       while (isalnum(peek()) || peek() == '_') advance();
       return source.substr(start, pos - start);
   }

public:
   AriaLexer(std::string src) : source(src) { stateStack.push(STATE_ROOT); }

   Token nextToken() {
       char c = peek();
       if (c == 0) return {TOKEN_EOF, "", line, col};

       // Recursive String Template Logic
       if (stateStack.top() == STATE_STRING_TEMPLATE) {
           if (c == '`') {
               advance();
               stateStack.pop();
               return {TOKEN_BACKTICK, "`", line, col};
           }
           if (c == '&' && peekNext() == '{') {
               advance();
               advance();
               stateStack.push(STATE_INTERPOLATION);
               return {TOKEN_INTERP_START, "&{", line, col};
           }
           // ... consume string content ...
       }
      
       // Symbol Sanitization: Reject @tesla
       if (c == '@') {
           advance();
           // Check if what follows is an identifier (directive) or just the operator
           if (isalpha(peek())) {
               size_t reset_pos = pos;
               std::string directive = parseIdentifier();
               
               // Explicitly ban unauthorized symbols
               if (directive.find("tesla") != std::string::npos) 
                   return {TOKEN_INVALID, "ILLEGAL_SYMBOL", line, col};

               // If it's just @varname, it's valid, but we need to verify 
               // in parser phase. For lexer, we just emit TOKEN_AT.
               // We reset pos to let the parser consume the identifier next.
               pos = reset_pos;
           }
           return {TOKEN_AT, "@", line, col};
       }

       // ... Standard tokenization logic ...
       return {TOKEN_INVALID, "UNKNOWN", line, col};
   }
};

/* ==========================================================================
   MODULE: FRONTEND / PARSER (DECLARATIONS)
   FILE: src/frontend/parser_decl.cpp
   ========================================================================== */
// Implementation of Variable Declaration Parsing with Colon Syntax Anchor
#include "parser.h"
#include "ast.h"
#include "lexer_utils.h"

// Parses: [wild|stack] Type:Identifier [= Expression];
// Grammar:
//   VarDecl -> ( "wild" | "stack" )? TypeIdentifier ":" Identifier ( "=" Expression )? ";"

std::unique_ptr<VarDecl> Parser::parseVarDecl() {
   bool is_wild = false;
   bool is_stack = false;

   // 1. Check for Memory Strategy Keywords
   // We explicitly check for 'wild' and 'stack'. If neither is present,
   // the variable defaults to 'managed' (GC).
   if (match(TOKEN_WILD)) {
       is_wild = true;
   } else if (match(TOKEN_STACK)) {
       is_stack = true;
   }

   // 2. Parse Type (e.g., int8, string, or user-defined struct)
   // We expect a TYPE_IDENTIFIER or an existing struct name.
   // In Aria, types are distinct tokens or identifiers known to be types.
   Token typeToken = consume(TOKEN_TYPE_IDENTIFIER, "Expected type name");

   // 3. The Anchor: Require Colon
   // This is the syntactic sugar that removes C++ style ambiguity.
   // If the colon is missing, this is NOT a declaration.
   consume(TOKEN_COLON, "Expected ':' after type in variable declaration");

   // 4. Parse Variable Name
   Token nameToken = consume(TOKEN_IDENTIFIER, "Expected variable name after ':'");

   // 5. Create AST Node
   auto decl = std::make_unique<VarDecl>(nameToken.lexeme, typeToken.lexeme);
   decl->is_wild = is_wild;
   decl->is_stack = is_stack;

   // 6. Handle Optional Assignment
   if (match(TOKEN_ASSIGN)) {
       decl->initializer = parseExpression();
   } else {
       // Validation: Wild pointers MUST be initialized or immediately unsafe.
       // Aria strict mode requires initialization to prevent using garbage values
       // from the unmanaged heap.
       if (is_wild && context->strictMode) {
            error("Wild variables must be initialized immediately.");
       }
   }

   // 7. Terminator
   consume(TOKEN_SEMICOLON, "Expected ';' after variable declaration");

   // 8. Register with Symbol Table for Scope Analysis
   // This allows subsequent code to resolve 'nameToken' as a variable.
   currentScope->define(decl->name, decl->type);

   return decl;
}

/* ==========================================================================
   MODULE: RUNTIME / I/O (WINDOWS)
   FILE: src/runtime/io_windows.cpp
   ========================================================================== */
#ifdef _WIN32
#include <windows.h>
#include <vector>

// Spawns a child process passing 6 distinct I/O channels via undocumented lpReserved2
void spawn_process_with_6_channels(const char* cmd, HANDLE hDbg, HANDLE hDati, HANDLE hDato) {
   STARTUPINFOA si;
   ZeroMemory(&si, sizeof(si));
   si.cb = sizeof(si);

   // Gather all 6 handles
   std::vector<HANDLE> handles = {
       GetStdHandle(STD_INPUT_HANDLE), 
       GetStdHandle(STD_OUTPUT_HANDLE), 
       GetStdHandle(STD_ERROR_HANDLE),
       hDbg, hDati, hDato
   };

   // Construct undocumented lpReserved2 buffer
   // Layout: [Count (4 bytes)][Flags (Count bytes)][Handles (Count * 4 bytes)]
   DWORD count = handles.size();
   DWORD cbReserved2 = 4 + count + (count * sizeof(HANDLE));

   // Allocate buffer in Local Heap (required by CreateProcess mechanics)
   LPBYTE lpReserved2 = (LPBYTE)LocalAlloc(LPTR, cbReserved2);

   // Write Count
   *((DWORD*)lpReserved2) = count;
   
   // Pointers to sections in the buffer
   LPBYTE flags_ptr = lpReserved2 + 4;
   UNALIGNED HANDLE* handle_ptr = (UNALIGNED HANDLE*)(lpReserved2 + 4 + count);

   // Set Flags (0x01 = FOPEN) and Copy Handles
   for(int i=0; i<count; i++) {
       flags_ptr[i] = 0x01; // Mark as Open File/Pipe
       handle_ptr[i] = handles[i];
       // Critical: Handles must be marked inheritable for child to use them
       SetHandleInformation(handles[i], HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT);
   }

   si.cbReserved2 = (WORD)cbReserved2;
   si.lpReserved2 = lpReserved2;
   // Flag to tell Windows to check std handles (and by extension reserved2)
   si.dwFlags |= STARTF_USESTDHANDLES;

   PROCESS_INFORMATION pi;
   if (CreateProcessA(NULL, (LPSTR)cmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {
       // Success - close handles in parent if necessary
       CloseHandle(pi.hProcess);
       CloseHandle(pi.hThread);
   }
   LocalFree(lpReserved2);
}
#endif

/* ==========================================================================
   MODULE: RUNTIME / I/O (LINUX)
   FILE: src/runtime/io_linux.cpp
   ========================================================================== */
// Implementation of 6-channel process spawning for Linux
#ifdef __linux__
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <vector>
#include <string>

// Maps the provided file descriptors to the Aria standard slots (0-5)
void spawn_process_linux(const char* cmd, const char* const argv, int fd_dbg, int fd_dati, int fd_dato) {
  pid_t pid = fork();
  if (pid < 0) {
      // Fork failed
      return;
  }

  if (pid == 0) {
      // --- CHILD PROCESS ---
      
      // 1. Remap Standard FDs (0, 1, 2)
      // (Assuming parent set up standard pipes before call, omitted for brevity)
      
      // 2. Remap Aria Extended FDs (3, 4, 5)
      // We use dup2 to force the provided FDs into specific slots.
      
      // STDDBG -> FD 3
      if (fd_dbg != 3) {
          dup2(fd_dbg, 3);
          close(fd_dbg);
      }
      
      // STDDATI -> FD 4
      if (fd_dati != 4) {
          dup2(fd_dati, 4);
          close(fd_dati);
      }
      
      // STDDATO -> FD 5
      if (fd_dato != 5) {
          dup2(fd_dato, 5);
          close(fd_dato);
      }

      // 3. Close Close-On-Exec flag if set
      // We need these FDs to persist across execvp.
      // Usually default is persistent, but we ensure it here.

      // 4. Execute
      // Cast argv to non-const for API compatibility
      execvp(cmd, (char* const*)argv);

      // If execvp returns, it failed
      _exit(127);
  } else {
      // --- PARENT PROCESS ---
      // Parent logic (tracking PID, closing write ends, etc.)
  }
}
#endif

/* ==========================================================================
   MODULE: RUNTIME / CONCURRENCY (SCHEDULER HEADERS)
   FILE: src/runtime/concurrency/scheduler.h
   ========================================================================== */
#include <vector>
#include <deque>
#include <thread>
#include <mutex>

// Task represents a suspended coroutine
struct Task {
   CoroutineFrame* frame;
   bool has_wild_affinity; // If true, cannot be stolen by other workers
   int affinity_thread_id; 
};

// Worker represents an OS thread
struct Worker {
   int id;
   std::deque<Task*> local_queue; // The Work-Stealing Deque
   std::mutex queue_lock;         // Spinlock for steal operations
};

// Global Scheduler Context
struct Scheduler {
   std::vector<std::thread> workers;
   std::vector<Worker*> queues;
   
   // Global lock only used during runtime initialization/shutdown
   std::mutex init_mutex;

   // Helper to push task to current thread's queue
   void schedule(Task* t) {
       // Implementation details omitted for brevity
   }
};

/* ==========================================================================
   MODULE: RUNTIME / CONCURRENCY (SCHEDULER LOGIC)
   FILE: src/runtime/concurrency/scheduler.cpp
   ========================================================================== */
// Implementation of the Work-Stealing Loop with Wild Affinity Support
#include "scheduler.h"

// The main loop for every OS thread (Worker)
void Worker::run() {
 while (true) {
     Task* task = nullptr;

     // 1. Try to pop from local queue (LIFO)
     // LIFO provides better cache locality for tasks that were just spawned.
     {
         std::lock_guard<std::mutex> lock(queue_lock);
         if (!local_queue.empty()) {
             task = local_queue.back();
             local_queue.pop_back();
         }
     }

     // 2. If local is empty, try to steal (FIFO)
     if (!task) {
         for (auto* victim : global_scheduler->queues) {
             if (victim == this) continue;
             
             std::lock_guard<std::mutex> victim_lock(victim->queue_lock);
             if (!victim->local_queue.empty()) {
                 Task* candidate = victim->local_queue.front();

                 // CRITICAL: Wild Affinity Check
                 // If the task has locked onto its thread (because it holds 
                 // thread-local wild memory), we cannot steal it.
                 if (candidate->has_wild_affinity && candidate->affinity_thread_id != this->id) {
                     continue; // Skip this task, it is pinned to the victim
                 }

                 // Steal successful
                 task = candidate;
                 victim->local_queue.pop_front();
                 break;
             }
         }
     }

     // 3. Execution
     if (task) {
         execute_coroutine(task->frame);
     } else {
         // No work found, yield to OS to prevent 100% CPU spin
         std::this_thread::yield();
     }
 }
}

/* ==========================================================================
   MODULE: BATTERIES / BLOCKCHAIN
   FILE: src/batteries/blockchain/pow.aria
   ========================================================================== */
// Reference Proof-of-Work Implementation in Aria
use std.crypto.sha256;
use std.time;

mod blockchain {

  // Block Header Structure
  // Using int64 for timestamp and nonce
  pub struct BlockHeader {
      int64: version;
      hash: prev_block; // 'hash' is a built-in 256-bit type alias
      hash: merkle_root;
      int64: timestamp;
      int64: difficulty; // Target bits
      int64: nonce;
  }

  // Mining Function
  // Returns the nonce that satisfies the difficulty
  pub func:mine = (BlockHeader:header) -> result<int64> {
      wild int64:nonce = 0;
      wild hash:target = calculateTarget(header.difficulty);
      
      // Start timing
      int64:start_time = time.now();

      // Infinite loop with manual break
      while(true) {
          header.nonce = nonce;

          // Serialize and Hash
          // Note: usage of unsafe wild pointer for buffer performance
          wild byte*:buffer = aria.alloc_buffer(sizeof(BlockHeader));
          defer aria.free(buffer);
          
          memcpy(buffer, @header, sizeof(BlockHeader));
          hash:h = sha256.hash(buffer);

          // Check difficulty (Spaceship operator handles big-int comparison)
          if (h < target) {
               print(`Block found! Nonce: &{nonce}`);
               return { val: nonce, err: NULL };
          }

          nonce++;
          
          // Safety break to prevent infinite hang in demo
          if (nonce > 10000000) {
              return { val: 0, err: "Timeout" };
          }
      }
  }
}

/* ==========================================================================
   MODULE: BUILD SYSTEM
   FILE: CMakeLists.txt
   ========================================================================== */
# CMakeLists.txt
# Root build script for Aria Compiler and Runtime
cmake_minimum_required(VERSION 3.14)
project(AriaCompiler VERSION 1.0 LANGUAGES C CXX)

# ==============================================================================
# 1. Dependency Resolution
# ==============================================================================

# Find LLVM 18+
# We require LLVM 18 specifically for the AVX-512 'VPTERNLOGD' intrinsic support
find_package(LLVM 18 REQUIRED CONFIG)
message(STATUS "Found LLVM ${LLVM_PACKAGE_VERSION}")
message(STATUS "Using LLVMConfig.cmake in: ${LLVM_DIR}")

llvm_map_components_to_libnames(llvm_libs core support native irreader)

include_directories(${LLVM_INCLUDE_DIRS})
add_definitions(${LLVM_DEFINITIONS})

# Integrate Mimalloc (Static Link for Wild Heap)
# We embed mimalloc from the 'vendor' directory to ensure version stability.
# By setting MI_BUILD_STATIC to ON, we tell mimalloc's own CMake to generate a.a/.lib
set(MI_BUILD_STATIC ON CACHE BOOL "Build static library")
set(MI_BUILD_SHARED OFF CACHE BOOL "Build shared library")
set(MI_BUILD_TESTS OFF CACHE BOOL "Build tests")
set(MI_OVERRIDE OFF CACHE BOOL "Do not override standard malloc globally yet")

add_subdirectory(vendor/mimalloc)

# ==============================================================================
# 2. Source Configuration
# ==============================================================================

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
# Enable strict warnings to catch potential pointer aliasing issues early
add_compile_options(-Wall -Wextra -Wno-unused-parameter)

include_directories(src)

# ==============================================================================
# 3. Target Definition: The Compiler (ariac)
# ==============================================================================

add_executable(ariac
 src/driver/main.cpp               # Compiler Driver Entry Point
 src/frontend/lexer.cpp
 src/frontend/parser_decl.cpp      # Implementation of Variable Declaration Parsing
 src/frontend/parser_pick.cpp      # New: Pick Parser
 src/frontend/ast/control_flow.cpp
 src/backend/codegen.cpp
 src/backend/lowering_ternary.cpp  # AVX-512 Lowering Logic
)

# Link against LLVM and Mimalloc
target_link_libraries(ariac 
 PRIVATE 
 ${llvm_libs}
 mimalloc-static
)

# ==============================================================================
# 4. Target Definition: The Runtime Library (libaria)
# ==============================================================================

# This library is linked into every compiled Aria program.
# It contains the GC, the Scheduler, and the bridge to Mimalloc.
add_library(aria_runtime STATIC
 src/runtime/memory/allocator.c        # The bridge (aria.alloc -> mi_malloc)
 src/runtime/gc/gc_impl.cpp            # NEW: Major/Minor GC Logic
 src/runtime/gc/nursery.cpp            # Fragmented Nursery Implementation
 src/runtime/io_windows.cpp            # lpReserved2 implementation
 src/runtime/io_linux.cpp              # Linux fork/dup2 implementation
 src/runtime/concurrency/scheduler.cpp # Work-stealing logic
 src/stdlib/io/fast_read.cpp
 src/runtime/core/string_impl.cpp      # SSO String Implementation
)

# Critical: The runtime MUST contain the static mimalloc symbols.
target_link_libraries(aria_runtime mimalloc-static)

# ==============================================================================
# 5. Build Artifacts
# ==============================================================================
message(STATUS "Aria Compiler Build Configured.")
message(STATUS "Run 'cmake --build .' to compile.")

/* ==========================================================================
   MODULE: DISTRIBUTION / INSTALLER
   FILE: dist/install_aria.sh
   ========================================================================== */
#!/bin/bash
# dist/install_aria.sh
# Official Aria Language AppImage Installer
# Best Practices Enforced:
# 1. No absolute paths in binary (handled by build system configuration)
# 2. Integration with ~/.local/share/applications for desktop menus
# 3. Symlinking to ~/.local/bin for CLI access without altering global /usr

set -e

# Resolve the absolute path of the installer script
APPIMAGE_PATH=$(realpath "$0")
INSTALL_DIR="$HOME/.local/bin"
DESKTOP_DIR="$HOME/.local/share/applications"
ICON_DIR="$HOME/.local/share/icons"

echo "=========================================="
echo "   Aria Language Environment Installer    "
echo "=========================================="

# 1. Create Directories
echo "[*] Creating user-local directories..."
mkdir -p "$INSTALL_DIR"
mkdir -p "$DESKTOP_DIR"
mkdir -p "$ICON_DIR"

# 2. Install Executable
# We recommend keeping the AppImage in a stable location like ~/Applications
TARGET_DIR="$HOME/Applications"
TARGET_APPIMAGE="$TARGET_DIR/aria-lang.AppImage"

mkdir -p "$TARGET_DIR"

if [ ! -f "$TARGET_APPIMAGE" ]; then
   echo "[*] Copying AppImage to $TARGET_APPIMAGE..."
   cp "$APPIMAGE_PATH" "$TARGET_APPIMAGE"
fi

chmod +x "$TARGET_APPIMAGE"

# 3. Create Desktop Entry
# This allows the Aria IDE or Compiler GUI to appear in system menus.
echo "[*] Generating Desktop Entry..."
cat > "$DESKTOP_DIR/aria-lang.desktop" <<EOF
[Desktop Entry]
Type=Application
Name=Aria Language
Comment=Aria High-Performance Systems Language
Exec="$TARGET_APPIMAGE"
Icon=aria-lang
Categories=Development;IDE;
Terminal=true
StartupNotify=true
EOF

# Make the desktop entry executable (required by some DEs)
chmod +x "$DESKTOP_DIR/aria-lang.desktop"

# 4. CLI Integration
# Add a symlink to PATH if it doesn't exist
if [ -L "$INSTALL_DIR/aria" ]; then
   rm "$INSTALL_DIR/aria"
fi

echo "[*] Linking 'aria' command to $INSTALL_DIR/aria..."
ln -s "$TARGET_APPIMAGE" "$INSTALL_DIR/aria"

# 5. Environment Check
if [[ ":$PATH:" != *":$INSTALL_DIR:"* ]]; then
   echo "WARNING: $INSTALL_DIR is not in your PATH."
   echo "Add the following to your shell config (.bashrc / .zshrc):"
   echo "export PATH=\"\$HOME/.local/bin:\$PATH\""
fi

echo "=========================================="
echo "   Installation Complete. Run 'aria'      "
echo "=========================================="
