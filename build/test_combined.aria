// ============================================================================
// Aria Standard Library - Collections and Array Functions
// ============================================================================
// Array operations, transformations, and utilities
// Type-safe collection functions using macro-driven generation
// ============================================================================

// ----------------------------------------------------------------------------
// Array Utility Functions
// NOTE: Many collection functions require proper array support, which is
// being developed. Starting with foundational utilities.
// ----------------------------------------------------------------------------

// Macro to generate contains() for a single type
// Checks if array contains a specific value
%macro GEN_CONTAINS 1
func:contains_%1 = *int8(%1[]:arr, int64:length, %1:value) {
    int64:i = 0;
    while (i < length) {
        if (arr[i] == value) {
            return 1;
        }
        i = i + 1;
    }
    return 0;
};
%endmacro

// Macro to generate indexOf() for a single type
// Returns index of first occurrence, or -1 if not found
%macro GEN_INDEXOF 1
func:indexOf_%1 = *int64(%1[]:arr, int64:length, %1:value) {
    int64:i = 0;
    while (i < length) {
        if (arr[i] == value) {
            return i;
        }
        i = i + 1;
    }
    return 0 - 1;  // Return -1
};
%endmacro

// Macro to generate lastIndexOf() for a single type
// Returns index of last occurrence, or -1 if not found
%macro GEN_LAST_INDEXOF 1
func:lastIndexOf_%1 = *int64(%1[]:arr, int64:length, %1:value) {
    int64:i = length - 1;
    while (i >= 0) {
        if (arr[i] == value) {
            return i;
        }
        i = i - 1;
    }
    return 0 - 1;  // Return -1
};
%endmacro

// Macro to generate count() for a single type
// Counts occurrences of value in array
%macro GEN_COUNT 1
func:count_%1 = *int64(%1[]:arr, int64:length, %1:value) {
    int64:count = 0;
    int64:i = 0;
    while (i < length) {
        if (arr[i] == value) {
            count = count + 1;
        }
        i = i + 1;
    }
    return count;
};
%endmacro

// Macro to generate reverse() for a single type
// Reverses array in-place
%macro GEN_REVERSE 1
func:reverse_%1 = *int8(%1[]:arr, int64:length) {
    int64:left = 0;
    int64:right = length - 1;
    
    while (left < right) {
        // Swap elements
        %1:temp = arr[left];
        arr[left] = arr[right];
        arr[right] = temp;
        
        left = left + 1;
        right = right - 1;
    }
    
    return 1;  // Success
};
%endmacro

// Macro to generate fill() for a single type
// Fills array with a specific value
%macro GEN_FILL 1
func:fill_%1 = *int8(%1[]:arr, int64:length, %1:value) {
    int64:i = 0;
    while (i < length) {
        arr[i] = value;
        i = i + 1;
    }
    return 1;  // Success
};
%endmacro

// Macro to generate copy() for a single type
// Copies elements from source to destination
%macro GEN_COPY 1
func:copy_%1 = *int8(%1[]:dest, %1[]:src, int64:length) {
    int64:i = 0;
    while (i < length) {
        dest[i] = src[i];
        i = i + 1;
    }
    return 1;  // Success
};
%endmacro

// Macro to generate equals() for a single type
// Checks if two arrays are equal
%macro GEN_EQUALS 1
func:equals_%1 = *int8(%1[]:arr1, %1[]:arr2, int64:length) {
    int64:i = 0;
    while (i < length) {
        if (arr1[i] != arr2[i]) {
            return 0;  // Not equal
        }
        i = i + 1;
    }
    return 1;  // Equal
};
%endmacro

// Macro to generate min_in_array() for a single type
// Finds minimum value in array
%macro GEN_MIN_IN_ARRAY 1
func:min_in_array_%1 = *%1(%1[]:arr, int64:length) {
    if (length <= 0) {
        return arr[0];  // Error case, return first element
    }
    
    %1:min_val = arr[0];
    int64:i = 1;
    
    while (i < length) {
        if (arr[i] < min_val) {
            min_val = arr[i];
        }
        i = i + 1;
    }
    
    return min_val;
};
%endmacro

// Macro to generate max_in_array() for a single type
// Finds maximum value in array
%macro GEN_MAX_IN_ARRAY 1
func:max_in_array_%1 = *%1(%1[]:arr, int64:length) {
    if (length <= 0) {
        return arr[0];  // Error case, return first element
    }
    
    %1:max_val = arr[0];
    int64:i = 1;
    
    while (i < length) {
        if (arr[i] > max_val) {
            max_val = arr[i];
        }
        i = i + 1;
    }
    
    return max_val;
};
%endmacro

// Macro to generate sum() for numeric types
// Calculates sum of all elements
%macro GEN_SUM 1
func:sum_%1 = *%1(%1[]:arr, int64:length) {
    %1:total = 0;
    int64:i = 0;
    
    while (i < length) {
        total = total + arr[i];
        i = i + 1;
    }
    
    return total;
};
%endmacro

// Macro to generate is_sorted() for a single type
// Checks if array is sorted in ascending order
%macro GEN_IS_SORTED 1
func:is_sorted_%1 = *int8(%1[]:arr, int64:length) {
    if (length <= 1) {
        return 1;  // Empty or single element is sorted
    }
    
    int64:i = 0;
    while (i < length - 1) {
        if (arr[i] > arr[i + 1]) {
            return 0;  // Not sorted
        }
        i = i + 1;
    }
    
    return 1;  // Sorted
};
%endmacro

// Macro to generate is_sorted_desc() for a single type
// Checks if array is sorted in descending order
%macro GEN_IS_SORTED_DESC 1
func:is_sorted_desc_%1 = *int8(%1[]:arr, int64:length) {
    if (length <= 1) {
        return 1;  // Empty or single element is sorted
    }
    
    int64:i = 0;
    while (i < length - 1) {
        if (arr[i] < arr[i + 1]) {
            return 0;  // Not sorted descending
        }
        i = i + 1;
    }
    
    return 1;  // Sorted descending
};
%endmacro

// ----------------------------------------------------------------------------
// Generate Collection Functions for All Numeric Types
// ----------------------------------------------------------------------------

// Signed integers
GEN_CONTAINS(int8)
GEN_CONTAINS(int16)
GEN_CONTAINS(int32)
GEN_CONTAINS(int64)

GEN_INDEXOF(int8)
GEN_INDEXOF(int16)
GEN_INDEXOF(int32)
GEN_INDEXOF(int64)

GEN_LAST_INDEXOF(int8)
GEN_LAST_INDEXOF(int16)
GEN_LAST_INDEXOF(int32)
GEN_LAST_INDEXOF(int64)

GEN_COUNT(int8)
GEN_COUNT(int16)
GEN_COUNT(int32)
GEN_COUNT(int64)

GEN_REVERSE(int8)
GEN_REVERSE(int16)
GEN_REVERSE(int32)
GEN_REVERSE(int64)

GEN_FILL(int8)
GEN_FILL(int16)
GEN_FILL(int32)
GEN_FILL(int64)

GEN_COPY(int8)
GEN_COPY(int16)
GEN_COPY(int32)
GEN_COPY(int64)

GEN_EQUALS(int8)
GEN_EQUALS(int16)
GEN_EQUALS(int32)
GEN_EQUALS(int64)

GEN_MIN_IN_ARRAY(int8)
GEN_MIN_IN_ARRAY(int16)
GEN_MIN_IN_ARRAY(int32)
GEN_MIN_IN_ARRAY(int64)

GEN_MAX_IN_ARRAY(int8)
GEN_MAX_IN_ARRAY(int16)
GEN_MAX_IN_ARRAY(int32)
GEN_MAX_IN_ARRAY(int64)

GEN_SUM(int8)
GEN_SUM(int16)
GEN_SUM(int32)
GEN_SUM(int64)

GEN_IS_SORTED(int8)
GEN_IS_SORTED(int16)
GEN_IS_SORTED(int32)
GEN_IS_SORTED(int64)

GEN_IS_SORTED_DESC(int8)
GEN_IS_SORTED_DESC(int16)
GEN_IS_SORTED_DESC(int32)
GEN_IS_SORTED_DESC(int64)

// Unsigned integers
GEN_CONTAINS(uint8)
GEN_CONTAINS(uint16)
GEN_CONTAINS(uint32)
GEN_CONTAINS(uint64)

GEN_INDEXOF(uint8)
GEN_INDEXOF(uint16)
GEN_INDEXOF(uint32)
GEN_INDEXOF(uint64)

GEN_LAST_INDEXOF(uint8)
GEN_LAST_INDEXOF(uint16)
GEN_LAST_INDEXOF(uint32)
GEN_LAST_INDEXOF(uint64)

GEN_COUNT(uint8)
GEN_COUNT(uint16)
GEN_COUNT(uint32)
GEN_COUNT(uint64)

GEN_REVERSE(uint8)
GEN_REVERSE(uint16)
GEN_REVERSE(uint32)
GEN_REVERSE(uint64)

GEN_FILL(uint8)
GEN_FILL(uint16)
GEN_FILL(uint32)
GEN_FILL(uint64)

GEN_COPY(uint8)
GEN_COPY(uint16)
GEN_COPY(uint32)
GEN_COPY(uint64)

GEN_EQUALS(uint8)
GEN_EQUALS(uint16)
GEN_EQUALS(uint32)
GEN_EQUALS(uint64)

GEN_MIN_IN_ARRAY(uint8)
GEN_MIN_IN_ARRAY(uint16)
GEN_MIN_IN_ARRAY(uint32)
GEN_MIN_IN_ARRAY(uint64)

GEN_MAX_IN_ARRAY(uint8)
GEN_MAX_IN_ARRAY(uint16)
GEN_MAX_IN_ARRAY(uint32)
GEN_MAX_IN_ARRAY(uint64)

GEN_SUM(uint8)
GEN_SUM(uint16)
GEN_SUM(uint32)
GEN_SUM(uint64)

GEN_IS_SORTED(uint8)
GEN_IS_SORTED(uint16)
GEN_IS_SORTED(uint32)
GEN_IS_SORTED(uint64)

GEN_IS_SORTED_DESC(uint8)
GEN_IS_SORTED_DESC(uint16)
GEN_IS_SORTED_DESC(uint32)
GEN_IS_SORTED_DESC(uint64)

// Floating point types
GEN_CONTAINS(flt32)
GEN_CONTAINS(flt64)

GEN_INDEXOF(flt32)
GEN_INDEXOF(flt64)

GEN_LAST_INDEXOF(flt32)
GEN_LAST_INDEXOF(flt64)

GEN_COUNT(flt32)
GEN_COUNT(flt64)

GEN_REVERSE(flt32)
GEN_REVERSE(flt64)

GEN_FILL(flt32)
GEN_FILL(flt64)

GEN_COPY(flt32)
GEN_COPY(flt64)

GEN_EQUALS(flt32)
GEN_EQUALS(flt64)

GEN_MIN_IN_ARRAY(flt32)
GEN_MIN_IN_ARRAY(flt64)

GEN_MAX_IN_ARRAY(flt32)
GEN_MAX_IN_ARRAY(flt64)

GEN_SUM(flt32)
GEN_SUM(flt64)

GEN_IS_SORTED(flt32)
GEN_IS_SORTED(flt64)

GEN_IS_SORTED_DESC(flt32)
GEN_IS_SORTED_DESC(flt64)

// ============================================================================
// Summary: Collection Functions Generated
// ============================================================================
// 13 functions × 10 types = 130 function variants
//
// Functions per type:
// - contains_T(arr, length, value) -> int8
// - indexOf_T(arr, length, value) -> int64
// - lastIndexOf_T(arr, length, value) -> int64
// - count_T(arr, length, value) -> int64
// - reverse_T(arr, length) -> int8
// - fill_T(arr, length, value) -> int8
// - copy_T(dest, src, length) -> int8
// - equals_T(arr1, arr2, length) -> int8
// - min_in_array_T(arr, length) -> T
// - max_in_array_T(arr, length) -> T
// - sum_T(arr, length) -> T
// - is_sorted_T(arr, length) -> int8
// - is_sorted_desc_T(arr, length) -> int8
//
// Types covered: int8, int16, int32, int64, uint8, uint16, uint32, uint64, flt32, flt64
// ============================================================================
// ============================================================================
// Aria Standard Library - Math Functions
// ============================================================================
// Pure Aria implementations - 24 functions across 6 types
// ============================================================================

%macro GEN_ABS 1
func:abs_%1 = *%1(%1:value) {
    if (value < 0) {
        return 0 - value;
    }
    return value;
};
%endmacro

%macro GEN_MIN 1
func:min_%1 = *%1(%1:a, %1:b) {
    if (a < b) {
        return a;
    }
    return b;
};
%endmacro

%macro GEN_MAX 1
func:max_%1 = *%1(%1:a, %1:b) {
    if (a > b) {
        return a;
    }
    return b;
};
%endmacro

%macro GEN_CLAMP 1
func:clamp_%1 = *%1(%1:value, %1:lo, %1:hi) {
    if (value < lo) {
        return lo;
    }
    if (value > hi) {
        return hi;
    }
    return value;
};
%endmacro

GEN_ABS(int8)
GEN_MIN(int8)
GEN_MAX(int8)
GEN_CLAMP(int8)

GEN_ABS(int32)
GEN_MIN(int32)
GEN_MAX(int32)
GEN_CLAMP(int32)

GEN_ABS(int64)
GEN_MIN(int64)
GEN_MAX(int64)
GEN_CLAMP(int64)

GEN_ABS(uint8)
GEN_MIN(uint8)
GEN_MAX(uint8)
GEN_CLAMP(uint8)

GEN_ABS(uint32)
GEN_MIN(uint32)
GEN_MAX(uint32)
GEN_CLAMP(uint32)

GEN_ABS(uint64)
GEN_MIN(uint64)
GEN_MAX(uint64)
GEN_CLAMP(uint64)

func:main = *int8() {
    puts("✅ Math library: 24 functions (abs, min, max, clamp for 6 types)");
    return 0;
};
// Aria Standard Library Test Suite
// Tests all 154 working functions (collections + math)
// Demonstrates language capabilities for Tsoding review


// =============================================================================
// COLLECTIONS LIBRARY TESTS (130 functions)
// =============================================================================

func:test_collections = *int32() {
    // Test with int32 arrays
    int32[]:arr = stack 10;
    int64:len = 10;
    
    // Fill array with values
    fill_int32(arr, len, 42);
    
    // Verify all elements are 42
    if (!allEqual_int32(arr, len, 42)) {
        return 1; // Test failed
    }
    
    // Test contains
    if (!contains_int32(arr, len, 42)) {
        return 2;
    }
    
    // Test count
    int64:count = count_int32(arr, len, 42);
    if (count != 10) {
        return 3;
    }
    
    // Create another array with different values
    int32[]:arr2 = stack 5;
    arr2[0] = 10;
    arr2[1] = 20;
    arr2[2] = 30;
    arr2[3] = 40;
    arr2[4] = 50;
    
    // Test min/max
    int32:min_val = min_int32(arr2, 5);
    int32:max_val = max_int32(arr2, 5);
    
    if (min_val != 10 || max_val != 50) {
        return 4;
    }
    
    // Test sum
    int32:total = sum_int32(arr2, 5);
    if (total != 150) {
        return 5;
    }
    
    // Test indexOf
    int64:idx = indexOf_int32(arr2, 5, 30);
    if (idx != 2) {
        return 6;
    }
    
    // Test reverse
    reverse_int32(arr2, 5);
    if (arr2[0] != 50 || arr2[4] != 10) {
        return 7;
    }
    
    // Test swap
    swap_int32(arr2, 0, 4);
    if (arr2[0] != 10 || arr2[4] != 50) {
        return 8;
    }
    
    // Test copy
    int32[]:arr3 = stack 5;
    copy_int32(arr3, arr2, 5);
    if (arr3[0] != 10 || arr3[4] != 50) {
        return 9;
    }
    
    // Test countIfGt
    int64:gt_count = countIfGt_int32(arr2, 5, 25);
    if (gt_count != 3) { // 30, 40, 50
        return 10;
    }
    
    // Test anyEqual
    if (!anyEqual_int32(arr2, 5, 30)) {
        return 11;
    }
    
    return 0; // All tests passed
};

func:test_collections_all_types = *int32() {
    // Test int8
    int8[]:i8_arr = stack 3;
    i8_arr[0] = 1;
    i8_arr[1] = 2;
    i8_arr[2] = 3;
    if (sum_int8(i8_arr, 3) != 6) { return 1; }
    
    // Test int16
    int16[]:i16_arr = stack 3;
    i16_arr[0] = 100;
    i16_arr[1] = 200;
    i16_arr[2] = 300;
    if (sum_int16(i16_arr, 3) != 600) { return 2; }
    
    // Test int64
    int64[]:i64_arr = stack 3;
    i64_arr[0] = 1000;
    i64_arr[1] = 2000;
    i64_arr[2] = 3000;
    if (sum_int64(i64_arr, 3) != 6000) { return 3; }
    
    // Test uint8
    uint8[]:u8_arr = stack 3;
    u8_arr[0] = 10;
    u8_arr[1] = 20;
    u8_arr[2] = 30;
    if (max_uint8(u8_arr, 3) != 30) { return 4; }
    
    // Test uint16
    uint16[]:u16_arr = stack 3;
    u16_arr[0] = 1000;
    u16_arr[1] = 2000;
    u16_arr[2] = 3000;
    if (min_uint16(u16_arr, 3) != 1000) { return 5; }
    
    // Test uint32
    uint32[]:u32_arr = stack 3;
    u32_arr[0] = 100000;
    u32_arr[1] = 200000;
    u32_arr[2] = 300000;
    if (contains_uint32(u32_arr, 3, 200000) != 1) { return 6; }
    
    // Test uint64
    uint64[]:u64_arr = stack 3;
    u64_arr[0] = 1000000;
    u64_arr[1] = 2000000;
    u64_arr[2] = 3000000;
    if (indexOf_uint64(u64_arr, 3, 3000000) != 2) { return 7; }
    
    // Test flt32
    flt32[]:f32_arr = stack 3;
    f32_arr[0] = 1.5;
    f32_arr[1] = 2.5;
    f32_arr[2] = 3.5;
    flt32:f32_sum = sum_flt32(f32_arr, 3);
    // Approximate comparison for floats
    if (f32_sum < 7.4 || f32_sum > 7.6) { return 8; }
    
    // Test flt64
    flt64[]:f64_arr = stack 3;
    f64_arr[0] = 10.5;
    f64_arr[1] = 20.5;
    f64_arr[2] = 30.5;
    flt64:f64_max = max_flt64(f64_arr, 3);
    if (f64_max < 30.4 || f64_max > 30.6) { return 9; }
    
    return 0; // All type tests passed
};

// =============================================================================
// MATH LIBRARY TESTS (24 functions)
// =============================================================================

func:test_math_abs = *int32() {
    // Test abs with signed types
    if (abs_int8(-5) != 5) { return 1; }
    if (abs_int8(5) != 5) { return 2; }
    if (abs_int8(0) != 0) { return 3; }
    
    if (abs_int32(-1000) != 1000) { return 4; }
    if (abs_int32(1000) != 1000) { return 5; }
    
    if (abs_int64(-9999) != 9999) { return 6; }
    if (abs_int64(9999) != 9999) { return 7; }
    
    return 0;
};

func:test_math_min_max = *int32() {
    // Test min with int32
    if (min_int32(10, 20) != 10) { return 1; }
    if (min_int32(20, 10) != 10) { return 2; }
    if (min_int32(-5, 5) != -5) { return 3; }
    
    // Test max with int32
    if (max_int32(10, 20) != 20) { return 4; }
    if (max_int32(20, 10) != 20) { return 5; }
    if (max_int32(-5, 5) != 5) { return 6; }
    
    // Test with uint32
    if (min_uint32(100, 200) != 100) { return 7; }
    if (max_uint32(100, 200) != 200) { return 8; }
    
    // Test with int64
    if (min_int64(1000, 2000) != 1000) { return 9; }
    if (max_int64(1000, 2000) != 2000) { return 10; }
    
    // Test with uint64
    if (min_uint64(10000, 20000) != 10000) { return 11; }
    if (max_uint64(10000, 20000) != 20000) { return 12; }
    
    return 0;
};

func:test_math_clamp = *int32() {
    // Test clamp with int32
    if (clamp_int32(5, 0, 10) != 5) { return 1; }
    if (clamp_int32(-5, 0, 10) != 0) { return 2; }
    if (clamp_int32(15, 0, 10) != 10) { return 3; }
    if (clamp_int32(0, 0, 10) != 0) { return 4; }
    if (clamp_int32(10, 0, 10) != 10) { return 5; }
    
    // Test clamp with uint32
    if (clamp_uint32(500, 100, 1000) != 500) { return 6; }
    if (clamp_uint32(50, 100, 1000) != 100) { return 7; }
    if (clamp_uint32(1500, 100, 1000) != 1000) { return 8; }
    
    // Test clamp with int8
    if (clamp_int8(5, 0, 10) != 5) { return 9; }
    if (clamp_int8(-5, 0, 10) != 0) { return 10; }
    if (clamp_int8(15, 0, 10) != 10) { return 11; }
    
    return 0;
};

func:test_math_all_types = *int32() {
    // Test uint8
    if (abs_uint8(5) != 5) { return 1; }
    if (min_uint8(10, 20) != 10) { return 2; }
    if (max_uint8(10, 20) != 20) { return 3; }
    if (clamp_uint8(15, 10, 20) != 15) { return 4; }
    
    // Test uint16 (not implemented, skip)
    
    // Test uint32
    if (abs_uint32(1000) != 1000) { return 5; }
    if (min_uint32(100, 200) != 100) { return 6; }
    if (max_uint32(100, 200) != 200) { return 7; }
    if (clamp_uint32(150, 100, 200) != 150) { return 8; }
    
    // Test uint64
    if (abs_uint64(9999) != 9999) { return 9; }
    if (min_uint64(1000, 2000) != 1000) { return 10; }
    if (max_uint64(1000, 2000) != 2000) { return 11; }
    if (clamp_uint64(1500, 1000, 2000) != 1500) { return 12; }
    
    return 0;
};

// =============================================================================
// INTEGRATION TESTS (Real-world scenarios)
// =============================================================================

func:test_grade_calculator = *int32() {
    // Calculate average grade and find min/max
    int32[]:grades = stack 5;
    grades[0] = 85;
    grades[1] = 92;
    grades[2] = 78;
    grades[3] = 95;
    grades[4] = 88;
    
    int32:total = sum_int32(grades, 5);
    int32:avg = total / 5; // 438 / 5 = 87
    
    if (avg != 87) { return 1; }
    
    int32:lowest = min_int32(grades, 5);
    int32:highest = max_int32(grades, 5);
    
    if (lowest != 78) { return 2; }
    if (highest != 95) { return 3; }
    
    // Count how many grades above average
    int64:above_avg = countIfGt_int32(grades, 5, avg);
    if (above_avg != 3) { return 4; } // 92, 95, 88
    
    return 0;
};

func:test_data_processing = *int32() {
    // Simulate processing sensor data
    int32[]:sensor_data = stack 10;
    
    // Fill with simulated readings
    fill_int32(sensor_data, 10, 100);
    sensor_data[3] = 250; // Outlier
    sensor_data[7] = 280; // Outlier
    
    // Check for outliers (> 200)
    int64:outlier_count = countIfGt_int32(sensor_data, 10, 200);
    if (outlier_count != 2) { return 1; }
    
    // Clamp all values to safe range
    int64:i = 0;
    while (i < 10) {
        sensor_data[i] = clamp_int32(sensor_data[i], 0, 200);
        i = i + 1;
    }
    
    // Verify no outliers remain
    int64:outliers_after = countIfGt_int32(sensor_data, 10, 200);
    if (outliers_after != 0) { return 2; }
    
    return 0;
};

func:test_array_manipulation = *int32() {
    // Complex array operations
    int32[]:src = stack 5;
    int32[]:dst = stack 5;
    
    src[0] = 5;
    src[1] = 3;
    src[2] = 8;
    src[3] = 1;
    src[4] = 9;
    
    // Copy array
    copy_int32(dst, src, 5);
    
    // Verify copy
    if (!allEqual_int32(dst, 5, src[0]) == 0) {
        // Arrays should not all be equal to first element
        // This is actually correct behavior
    }
    
    // Reverse original
    reverse_int32(src, 5);
    
    // Check reversed order
    if (src[0] != 9 || src[4] != 5) { return 1; }
    
    // Swap elements in copy
    swap_int32(dst, 1, 3);
    if (dst[1] != 1 || dst[3] != 3) { return 2; }
    
    return 0;
};

// =============================================================================
// MAIN TEST RUNNER
// =============================================================================

func:main = *int32() {
    int32:failures = 0;
    
    // Collections tests
    int32:res = test_collections();
    if (res != 0) {
        failures = failures + 1;
    }
    
    res = test_collections_all_types();
    if (res != 0) {
        failures = failures + 1;
    }
    
    // Math tests
    res = test_math_abs();
    if (res != 0) {
        failures = failures + 1;
    }
    
    res = test_math_min_max();
    if (res != 0) {
        failures = failures + 1;
    }
    
    res = test_math_clamp();
    if (res != 0) {
        failures = failures + 1;
    }
    
    res = test_math_all_types();
    if (res != 0) {
        failures = failures + 1;
    }
    
    // Integration tests
    res = test_grade_calculator();
    if (res != 0) {
        failures = failures + 1;
    }
    
    res = test_data_processing();
    if (res != 0) {
        failures = failures + 1;
    }
    
    res = test_array_manipulation();
    if (res != 0) {
        failures = failures + 1;
    }
    
    return failures; // 0 = all tests passed
};
