// Aria Standard Library - Math Functions
// Basic mathematical operations and utilities

mod math {
    // Absolute value
    pub func:abs = *int64(int64:n) {
        if (n < 0) {
            return { err: 0, val: -n };
        } else {
            return { err: 0, val: n };
        }
    };

    // Minimum of two values
    pub func:min = *int64(int64:a, int64:b) {
        if (a < b) {
            return { err: 0, val: a };
        } else {
            return { err: 0, val: b };
        }
    };

    // Maximum of two values
    pub func:max = *int64(int64:a, int64:b) {
        if (a > b) {
            return { err: 0, val: a };
        } else {
            return { err: 0, val: b };
        }
    };

    // Clamp value between min and max
    pub func:clamp = *int64(int64:val, int64:minVal, int64:maxVal) {
        if (val < minVal) {
            return { err: 0, val: minVal };
        } else {
            if (val > maxVal) {
                return { err: 0, val: maxVal };
            } else {
                return { err: 0, val: val };
            }
        }
    };

    // Power function (integer exponent)
    pub func:pow = *int64(int64:base, int64:exp) {
        if (exp < 0) {
            return { err: 1, val: 0 }; // Negative exponents not supported
        }
        
        int64:result = 1;
        int64:i = 0;
        
        while (i < exp) {
            result = result * base;
            i = i + 1;
        }
        
        return { err: 0, val: result };
    };

    // Greatest common divisor (Euclidean algorithm)
    pub func:gcd = *int64(int64:a, int64:b) {
        int64:x = a;
        int64:y = b;
        
        while (y != 0) {
            int64:temp = y;
            y = x % y;
            x = temp;
        }
        
        return { err: 0, val: x };
    };

    // Least common multiple
    pub func:lcm = *int64(int64:a, int64:b) {
        result:gcdResult = gcd(a, b);
        if (gcdResult.err != 0) {
            return gcdResult;
        }
        
        int64:product = a * b;
        int64:lcmVal = product / gcdResult.val;
        
        return { err: 0, val: lcmVal };
    };

    // Check if number is prime
    pub func:isPrime = *bool(int64:n) {
        if (n < 2) {
            return { err: 0, val: false };
        }
        
        if (n == 2) {
            return { err: 0, val: true };
        }
        
        if (n % 2 == 0) {
            return { err: 0, val: false };
        }
        
        int64:i = 3;
        while (i * i <= n) {
            if (n % i == 0) {
                return { err: 0, val: false };
            }
            i = i + 2;
        }
        
        return { err: 0, val: true };
    };

    // Factorial
    pub func:factorial = *int64(int64:n) {
        if (n < 0) {
            return { err: 1, val: 0 }; // Negative factorial undefined
        }
        
        if (n == 0) {
            return { err: 0, val: 1 };
        }
        
        int64:result = 1;
        int64:i = 1;
        
        while (i <= n) {
            result = result * i;
            i = i + 1;
        }
        
        return { err: 0, val: result };
    };
}
