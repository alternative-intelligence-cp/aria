// ============================================================================
// Aria Standard Library - Math Functions
// ============================================================================
// Core mathematical functions generated for all numeric types using macros
// Demonstrates metaprogramming-driven stdlib development
// ============================================================================

// ----------------------------------------------------------------------------
// Type List Macros - Define once, generate for all types
// ----------------------------------------------------------------------------

// Macro to generate abs() for a single type

// Macro to generate min() for a single type

// Macro to generate max() for a single type

// Macro to generate clamp() for a single type

// ----------------------------------------------------------------------------
// Generate for Signed Integers: int8, int16, int32, int64
// ----------------------------------------------------------------------------


func:abs_int8 = *int8(int8:value) {
    if (value < 0) {
        return 0 - value;
    }
    return value;
};


func:min_int8 = *int8(int8:a, int8:b) {
    if (a < b) {
        return a;
    }
    return b;
};


func:max_int8 = *int8(int8:a, int8:b) {
    if (a > b) {
        return a;
    }
    return b;
};


func:clamp_int8 = *int8(int8:value, int8:min_val, int8:max_val) {
    if (value < min_val) {
        return min_val;
    }
    if (value > max_val) {
        return max_val;
    }
    return value;
};



func:abs_int16 = *int16(int16:value) {
    if (value < 0) {
        return 0 - value;
    }
    return value;
};


func:min_int16 = *int16(int16:a, int16:b) {
    if (a < b) {
        return a;
    }
    return b;
};


func:max_int16 = *int16(int16:a, int16:b) {
    if (a > b) {
        return a;
    }
    return b;
};


func:clamp_int16 = *int16(int16:value, int16:min_val, int16:max_val) {
    if (value < min_val) {
        return min_val;
    }
    if (value > max_val) {
        return max_val;
    }
    return value;
};



func:abs_int32 = *int32(int32:value) {
    if (value < 0) {
        return 0 - value;
    }
    return value;
};


func:min_int32 = *int32(int32:a, int32:b) {
    if (a < b) {
        return a;
    }
    return b;
};


func:max_int32 = *int32(int32:a, int32:b) {
    if (a > b) {
        return a;
    }
    return b;
};


func:clamp_int32 = *int32(int32:value, int32:min_val, int32:max_val) {
    if (value < min_val) {
        return min_val;
    }
    if (value > max_val) {
        return max_val;
    }
    return value;
};



func:abs_int64 = *int64(int64:value) {
    if (value < 0) {
        return 0 - value;
    }
    return value;
};


func:min_int64 = *int64(int64:a, int64:b) {
    if (a < b) {
        return a;
    }
    return b;
};


func:max_int64 = *int64(int64:a, int64:b) {
    if (a > b) {
        return a;
    }
    return b;
};


func:clamp_int64 = *int64(int64:value, int64:min_val, int64:max_val) {
    if (value < min_val) {
        return min_val;
    }
    if (value > max_val) {
        return max_val;
    }
    return value;
};


// ----------------------------------------------------------------------------
// Generate for Unsigned Integers: uint8, uint16, uint32, uint64
// Note: abs() for unsigned is identity function (always positive)
// ----------------------------------------------------------------------------



func:abs_uint8 = *uint8(uint8:value) {
    return value;
};


func:min_uint8 = *uint8(uint8:a, uint8:b) {
    if (a < b) {
        return a;
    }
    return b;
};


func:max_uint8 = *uint8(uint8:a, uint8:b) {
    if (a > b) {
        return a;
    }
    return b;
};


func:clamp_uint8 = *uint8(uint8:value, uint8:min_val, uint8:max_val) {
    if (value < min_val) {
        return min_val;
    }
    if (value > max_val) {
        return max_val;
    }
    return value;
};



func:abs_uint16 = *uint16(uint16:value) {
    return value;
};


func:min_uint16 = *uint16(uint16:a, uint16:b) {
    if (a < b) {
        return a;
    }
    return b;
};


func:max_uint16 = *uint16(uint16:a, uint16:b) {
    if (a > b) {
        return a;
    }
    return b;
};


func:clamp_uint16 = *uint16(uint16:value, uint16:min_val, uint16:max_val) {
    if (value < min_val) {
        return min_val;
    }
    if (value > max_val) {
        return max_val;
    }
    return value;
};



func:abs_uint32 = *uint32(uint32:value) {
    return value;
};


func:min_uint32 = *uint32(uint32:a, uint32:b) {
    if (a < b) {
        return a;
    }
    return b;
};


func:max_uint32 = *uint32(uint32:a, uint32:b) {
    if (a > b) {
        return a;
    }
    return b;
};


func:clamp_uint32 = *uint32(uint32:value, uint32:min_val, uint32:max_val) {
    if (value < min_val) {
        return min_val;
    }
    if (value > max_val) {
        return max_val;
    }
    return value;
};



func:abs_uint64 = *uint64(uint64:value) {
    return value;
};


func:min_uint64 = *uint64(uint64:a, uint64:b) {
    if (a < b) {
        return a;
    }
    return b;
};


func:max_uint64 = *uint64(uint64:a, uint64:b) {
    if (a > b) {
        return a;
    }
    return b;
};


func:clamp_uint64 = *uint64(uint64:value, uint64:min_val, uint64:max_val) {
    if (value < min_val) {
        return min_val;
    }
    if (value > max_val) {
        return max_val;
    }
    return value;
};


// ----------------------------------------------------------------------------
// Generate for Floating Point: flt32, flt64
// ----------------------------------------------------------------------------


func:abs_flt32 = *flt32(flt32:value) {
    if (value < 0) {
        return 0 - value;
    }
    return value;
};


func:min_flt32 = *flt32(flt32:a, flt32:b) {
    if (a < b) {
        return a;
    }
    return b;
};


func:max_flt32 = *flt32(flt32:a, flt32:b) {
    if (a > b) {
        return a;
    }
    return b;
};


func:clamp_flt32 = *flt32(flt32:value, flt32:min_val, flt32:max_val) {
    if (value < min_val) {
        return min_val;
    }
    if (value > max_val) {
        return max_val;
    }
    return value;
};



func:abs_flt64 = *flt64(flt64:value) {
    if (value < 0) {
        return 0 - value;
    }
    return value;
};


func:min_flt64 = *flt64(flt64:a, flt64:b) {
    if (a < b) {
        return a;
    }
    return b;
};


func:max_flt64 = *flt64(flt64:a, flt64:b) {
    if (a > b) {
        return a;
    }
    return b;
};


func:clamp_flt64 = *flt64(flt64:value, flt64:min_val, flt64:max_val) {
    if (value < min_val) {
        return min_val;
    }
    if (value > max_val) {
        return max_val;
    }
    return value;
};


// ----------------------------------------------------------------------------
// Floating Point Math Functions (using LLVM intrinsics)
// ----------------------------------------------------------------------------

// Square root - only for floating point types

// Floor - round down to nearest integer

// Ceil - round up to nearest integer

// Round - round to nearest integer (ties to even)

// Trunc - round toward zero (remove fractional part)

// Power function - x^y

// Generate floating point math functions

func:sqrt_flt32 = *flt32(flt32:value) {
    if (value < 0.0) {
        fail(1);  // Error: negative input
    }
    // LLVM intrinsic: llvm.sqrt.f32/f64
    flt32:result_val = @llvm_sqrt_flt32(value);
    return result_val;
};

func:main = *int8() { return 0; };
