// Training Sample: Breadth-First Search (BFS)
// Demonstrates: graph traversal, queue usage, level-order

use aria.stdlib.collections;

struct Queue {
    int64[100]:data;
    int64:front;
    int64:rear;
    int64:size;
};

func:initQueue = *Queue() {
    Queue:q;
    q.front = 0;
    q.rear = -1;
    q.size = 0;
    return { err: 0, val: q };
};

func:enqueue = *int8(Queue:q, int64:value) {
    if (q.size >= 100) {
        return { err: 1, val: 0 };
    }
    q.rear = (q.rear + 1) % 100;
    q.data[q.rear] = value;
    q.size = q.size + 1;
    return { err: 0, val: 1 };
};

func:dequeue = *int64(Queue:q) {
    if (q.size == 0) {
        return { err: 1, val: 0 };
    }
    int64:value = q.data[q.front];
    q.front = (q.front + 1) % 100;
    q.size = q.size - 1;
    return { err: 0, val: value };
};

func:bfs = *int8(int64[10][10]:graph, int64:numVertices, int64:start) {
    bool[10]:visited;
    int64:i = 0;
    while (i < numVertices) {
        visited[i] = false;
        i = i + 1;
    }
    
    result:queueResult = initQueue();
    Queue:q = queueResult.val;
    
    visited[start] = true;
    enqueue(q, start);
    
    while (q.size > 0) {
        result:deqResult = dequeue(q);
        int64:current = deqResult.val;
        
        int64:j = 0;
        while (j < numVertices) {
            if (graph[current][j] == 1) {
                if (visited[j] == false) {
                    visited[j] = true;
                    enqueue(q, j);
                }
            }
            j = j + 1;
        }
    }
    
    return { err: 0, val: 1 };
};

func:main = *int8() {
    int64[10][10]:graph;
    
    // Initialize graph
    int64:i = 0;
    while (i < 10) {
        int64:j = 0;
        while (j < 10) {
            graph[i][j] = 0;
            j = j + 1;
        }
        i = i + 1;
    }
    
    // Add edges
    graph[0][1] = 1;
    graph[1][0] = 1;
    graph[0][2] = 1;
    graph[2][0] = 1;
    graph[1][3] = 1;
    graph[3][1] = 1;
    
    bfs(graph, 4, 0);
    
    return { err: 0, val: 0 };
};
