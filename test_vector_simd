; ModuleID = 'aria_module'
source_filename = "aria_module"

%result_int32 = type { i8, i32 }

@0 = private unnamed_addr constant [24 x i8] c"Vector SIMD test passed\00", align 1
@1 = private unnamed_addr constant [27 x i8] c"Integer vector test passed\00", align 1
@2 = private unnamed_addr constant [26 x i8] c"Double vector test passed\00", align 1

declare void @puts(ptr)

declare void @print(ptr)

declare void @llvm.coro.resume(ptr)

define void @aria_coro_resume_bridge(ptr %0) {
entry:
  call void @llvm.coro.resume(ptr %0)
  ret void
}

define internal void @__aria_module_init() {
entry:
  ret void
}

define internal %result_int32 @test_vec4_arithmetic() {
entry:
  %composed = alloca <4 x float>, align 16
  %offset = alloca <4 x float>, align 16
  %scaled = alloca <4 x float>, align 16
  %quot = alloca <4 x float>, align 16
  %prod = alloca <4 x float>, align 16
  %diff = alloca <4 x float>, align 16
  %sum = alloca <4 x float>, align 16
  %b = alloca <4 x float>, align 16
  %a = alloca <4 x float>, align 16
  store <4 x float> <float 1.000000e+00, float 2.000000e+00, float 3.000000e+00, float 4.000000e+00>, ptr %a, align 16
  store <4 x float> <float 5.000000e+00, float 6.000000e+00, float 7.000000e+00, float 8.000000e+00>, ptr %b, align 16
  %0 = load <4 x float>, ptr %a, align 16
  %1 = load <4 x float>, ptr %b, align 16
  %addtmp = fadd <4 x float> %0, %1
  store <4 x float> %addtmp, ptr %sum, align 16
  %2 = load <4 x float>, ptr %b, align 16
  %3 = load <4 x float>, ptr %a, align 16
  %subtmp = fsub <4 x float> %2, %3
  store <4 x float> %subtmp, ptr %diff, align 16
  %4 = load <4 x float>, ptr %a, align 16
  %5 = load <4 x float>, ptr %b, align 16
  %multmp = fmul <4 x float> %4, %5
  store <4 x float> %multmp, ptr %prod, align 16
  %6 = load <4 x float>, ptr %b, align 16
  %7 = load <4 x float>, ptr %a, align 16
  %divtmp = fdiv <4 x float> %6, %7
  store <4 x float> %divtmp, ptr %quot, align 16
  %8 = load <4 x float>, ptr %a, align 16
  %multmp1 = fmul <4 x float> %8, splat (float 2.000000e+00)
  store <4 x float> %multmp1, ptr %scaled, align 16
  %9 = load <4 x float>, ptr %a, align 16
  %addtmp2 = fadd <4 x float> %9, splat (float 1.000000e+01)
  store <4 x float> %addtmp2, ptr %offset, align 16
  store <4 x float> <float 1.000000e+00, float 2.000000e+00, float 3.000000e+00, float 4.000000e+00>, ptr %composed, align 16
  call void @puts(ptr @0)
  %result = alloca %result_int32, align 8
  %err_ptr = getelementptr inbounds nuw %result_int32, ptr %result, i32 0, i32 0
  store i8 0, ptr %err_ptr, align 1
  %val_ptr = getelementptr inbounds nuw %result_int32, ptr %result, i32 0, i32 1
  store i32 0, ptr %val_ptr, align 4
  %result_val = load %result_int32, ptr %result, align 4
  ret %result_int32 %result_val
}

define internal %result_int32 @test_ivec4_arithmetic() {
entry:
  %prod = alloca <4 x i32>, align 16
  %diff = alloca <4 x i32>, align 16
  %sum = alloca <4 x i32>, align 16
  %b = alloca <4 x i32>, align 16
  %a = alloca <4 x i32>, align 16
  store <4 x i32> <i32 1, i32 2, i32 3, i32 4>, ptr %a, align 16
  store <4 x i32> <i32 5, i32 6, i32 7, i32 8>, ptr %b, align 16
  %0 = load <4 x i32>, ptr %a, align 16
  %1 = load <4 x i32>, ptr %b, align 16
  %addtmp = add <4 x i32> %0, %1
  store <4 x i32> %addtmp, ptr %sum, align 16
  %2 = load <4 x i32>, ptr %b, align 16
  %3 = load <4 x i32>, ptr %a, align 16
  %subtmp = sub <4 x i32> %2, %3
  store <4 x i32> %subtmp, ptr %diff, align 16
  %4 = load <4 x i32>, ptr %a, align 16
  %5 = load <4 x i32>, ptr %b, align 16
  %multmp = mul <4 x i32> %4, %5
  store <4 x i32> %multmp, ptr %prod, align 16
  call void @puts(ptr @1)
  %result = alloca %result_int32, align 8
  %err_ptr = getelementptr inbounds nuw %result_int32, ptr %result, i32 0, i32 0
  store i8 0, ptr %err_ptr, align 1
  %val_ptr = getelementptr inbounds nuw %result_int32, ptr %result, i32 0, i32 1
  store i32 0, ptr %val_ptr, align 4
  %result_val = load %result_int32, ptr %result, align 4
  ret %result_int32 %result_val
}

define internal %result_int32 @test_dvec4_arithmetic() {
entry:
  %prod = alloca <4 x double>, align 32
  %sum = alloca <4 x double>, align 32
  %b = alloca <4 x double>, align 32
  %a = alloca <4 x double>, align 32
  store <4 x double> <double 1.000000e+00, double 2.000000e+00, double 3.000000e+00, double 4.000000e+00>, ptr %a, align 32
  store <4 x double> <double 5.000000e+00, double 6.000000e+00, double 7.000000e+00, double 8.000000e+00>, ptr %b, align 32
  %0 = load <4 x double>, ptr %a, align 32
  %1 = load <4 x double>, ptr %b, align 32
  %addtmp = fadd <4 x double> %0, %1
  store <4 x double> %addtmp, ptr %sum, align 32
  %2 = load <4 x double>, ptr %a, align 32
  %3 = load <4 x double>, ptr %b, align 32
  %multmp = fmul <4 x double> %2, %3
  store <4 x double> %multmp, ptr %prod, align 32
  call void @puts(ptr @2)
  %result = alloca %result_int32, align 8
  %err_ptr = getelementptr inbounds nuw %result_int32, ptr %result, i32 0, i32 0
  store i8 0, ptr %err_ptr, align 1
  %val_ptr = getelementptr inbounds nuw %result_int32, ptr %result, i32 0, i32 1
  store i32 0, ptr %val_ptr, align 4
  %result_val = load %result_int32, ptr %result, align 4
  ret %result_int32 %result_val
}

define internal %result_int32 @__user_main() {
entry:
  %calltmp = call %result_int32 @test_vec4_arithmetic()
  %calltmp1 = call %result_int32 @test_ivec4_arithmetic()
  %calltmp2 = call %result_int32 @test_dvec4_arithmetic()
  %result = alloca %result_int32, align 8
  %err_ptr = getelementptr inbounds nuw %result_int32, ptr %result, i32 0, i32 0
  store i8 0, ptr %err_ptr, align 1
  %val_ptr = getelementptr inbounds nuw %result_int32, ptr %result, i32 0, i32 1
  store i32 0, ptr %val_ptr, align 4
  %result_val = load %result_int32, ptr %result, align 4
  ret %result_int32 %result_val
}

define i64 @main() {
entry:
  call void @aria_scheduler_init(i32 0)
  call void @__aria_module_init()
  %0 = call %result_int32 @__user_main()
  ret i64 0
}

declare void @aria_scheduler_init(i32)
