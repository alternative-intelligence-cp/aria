// ============================================================================
// Aria Standard Library - Collections and Array Functions
// ============================================================================
// Array operations, transformations, and utilities
// Type-safe collection functions using macro-driven generation
// ============================================================================

// ----------------------------------------------------------------------------
// Array Utility Functions
// NOTE: Many collection functions require proper array support, which is
// being developed. Starting with foundational utilities.
// ----------------------------------------------------------------------------

// Macro to generate contains() for a single type
// Checks if array contains a specific value
%macro GEN_CONTAINS 1
func:contains_%1 = *int8(%1[]:arr, %1:length, %1:value) {
    int64:i = 0;
    while (i < length) {
        if (arr[i] == value) {
            return 1;
        }
        i = i + 1;
    }
    return 0;
};
%endmacro

// Macro to generate indexOf() for a single type
// Returns index of first occurrence, or -1 if not found
%macro GEN_INDEXOF 1
func:indexOf_%1 = *int64(%1[]:arr, int64:length, %1:value) {
    int64:i = 0;
    while (i < length) {
        if (arr[i] == value) {
            return i;
        }
        i = i + 1;
    }
    return 0 - 1;  // Return -1
};
%endmacro

// Macro to generate lastIndexOf() for a single type
// Returns index of last occurrence, or -1 if not found
%macro GEN_LAST_INDEXOF 1
func:lastIndexOf_%1 = *int64(%1[]:arr, int64:length, %1:value) {
    int64:i = length - 1;
    while (i >= 0) {
        if (arr[i] == value) {
            return i;
        }
        i = i - 1;
    }
    return 0 - 1;  // Return -1
};
%endmacro

// Macro to generate count() for a single type
// Counts occurrences of value in array
%macro GEN_COUNT 1
func:count_%1 = *int64(%1[]:arr, int64:length, %1:value) {
    int64:count = 0;
    int64:i = 0;
    while (i < length) {
        if (arr[i] == value) {
            count = count + 1;
        }
        i = i + 1;
    }
    return count;
};
%endmacro

// Macro to generate reverse() for a single type
// Reverses array in-place
%macro GEN_REVERSE 1
func:reverse_%1 = *int8(%1[]:arr, int64:length) {
    int64:left = 0;
    int64:right = length - 1;
    
    while (left < right) {
        // Swap elements
        %1:temp = arr[left];
        arr[left] = arr[right];
        arr[right] = temp;
        
        left = left + 1;
        right = right - 1;
    }
    
    return 1;  // Success
};
%endmacro

// Macro to generate fill() for a single type
// Fills array with a specific value
%macro GEN_FILL 1
func:fill_%1 = *int8(%1[]:arr, int64:length, %1:value) {
    int64:i = 0;
    while (i < length) {
        arr[i] = value;
        i = i + 1;
    }
    return 1;  // Success
};
%endmacro

// Macro to generate copy() for a single type
// Copies elements from source to destination
%macro GEN_COPY 1
func:copy_%1 = *int8(%1[]:dest, %1[]:src, int64:length) {
    int64:i = 0;
    while (i < length) {
        dest[i] = src[i];
        i = i + 1;
    }
    return 1;  // Success
};
%endmacro

// Macro to generate equals() for a single type
// Checks if two arrays are equal
%macro GEN_EQUALS 1
func:equals_%1 = *int8(%1[]:arr1, %1[]:arr2, int64:length) {
    int64:i = 0;
    while (i < length) {
        if (arr1[i] != arr2[i]) {
            return 0;  // Not equal
        }
        i = i + 1;
    }
    return 1;  // Equal
};
%endmacro

// Macro to generate min_in_array() for a single type
// Finds minimum value in array
%macro GEN_MIN_IN_ARRAY 1
func:min_in_array_%1 = *%1(%1[]:arr, int64:length) {
    if (length <= 0) {
        return arr[0];  // Error case, return first element
    }
    
    %1:min_val = arr[0];
    int64:i = 1;
    
    while (i < length) {
        if (arr[i] < min_val) {
            min_val = arr[i];
        }
        i = i + 1;
    }
    
    return min_val;
};
%endmacro

// Macro to generate max_in_array() for a single type
// Finds maximum value in array
%macro GEN_MAX_IN_ARRAY 1
func:max_in_array_%1 = *%1(%1[]:arr, int64:length) {
    if (length <= 0) {
        return arr[0];  // Error case, return first element
    }
    
    %1:max_val = arr[0];
    int64:i = 1;
    
    while (i < length) {
        if (arr[i] > max_val) {
            max_val = arr[i];
        }
        i = i + 1;
    }
    
    return max_val;
};
%endmacro

// Macro to generate sum() for numeric types
// Calculates sum of all elements
%macro GEN_SUM 1
func:sum_%1 = *%1(%1[]:arr, int64:length) {
    %1:total = 0;
    int64:i = 0;
    
    while (i < length) {
        total = total + arr[i];
        i = i + 1;
    }
    
    return total;
};
%endmacro

// Macro to generate is_sorted() for a single type
// Checks if array is sorted in ascending order
%macro GEN_IS_SORTED 1
func:is_sorted_%1 = *int8(%1[]:arr, int64:length) {
    if (length <= 1) {
        return 1;  // Empty or single element is sorted
    }
    
    int64:i = 0;
    while (i < length - 1) {
        if (arr[i] > arr[i + 1]) {
            return 0;  // Not sorted
        }
        i = i + 1;
    }
    
    return 1;  // Sorted
};
%endmacro

// Macro to generate is_sorted_desc() for a single type
// Checks if array is sorted in descending order
%macro GEN_IS_SORTED_DESC 1
func:is_sorted_desc_%1 = *int8(%1[]:arr, int64:length) {
    if (length <= 1) {
        return 1;  // Empty or single element is sorted
    }
    
    int64:i = 0;
    while (i < length - 1) {
        if (arr[i] < arr[i + 1]) {
            return 0;  // Not sorted descending
        }
        i = i + 1;
    }
    
    return 1;  // Sorted descending
};
%endmacro

// ----------------------------------------------------------------------------
// Generate Collection Functions for All Numeric Types
// ----------------------------------------------------------------------------

// Signed integers
GEN_CONTAINS(int8)
GEN_CONTAINS(int16)
GEN_CONTAINS(int32)
GEN_CONTAINS(int64)

GEN_INDEXOF(int8)
GEN_INDEXOF(int16)
GEN_INDEXOF(int32)
GEN_INDEXOF(int64)

GEN_LAST_INDEXOF(int8)
GEN_LAST_INDEXOF(int16)
GEN_LAST_INDEXOF(int32)
GEN_LAST_INDEXOF(int64)

GEN_COUNT(int8)
GEN_COUNT(int16)
GEN_COUNT(int32)
GEN_COUNT(int64)

GEN_REVERSE(int8)
GEN_REVERSE(int16)
GEN_REVERSE(int32)
GEN_REVERSE(int64)

GEN_FILL(int8)
GEN_FILL(int16)
GEN_FILL(int32)
GEN_FILL(int64)

GEN_COPY(int8)
GEN_COPY(int16)
GEN_COPY(int32)
GEN_COPY(int64)

GEN_EQUALS(int8)
GEN_EQUALS(int16)
GEN_EQUALS(int32)
GEN_EQUALS(int64)

GEN_MIN_IN_ARRAY(int8)
GEN_MIN_IN_ARRAY(int16)
GEN_MIN_IN_ARRAY(int32)
GEN_MIN_IN_ARRAY(int64)

GEN_MAX_IN_ARRAY(int8)
GEN_MAX_IN_ARRAY(int16)
GEN_MAX_IN_ARRAY(int32)
GEN_MAX_IN_ARRAY(int64)

GEN_SUM(int8)
GEN_SUM(int16)
GEN_SUM(int32)
GEN_SUM(int64)

GEN_IS_SORTED(int8)
GEN_IS_SORTED(int16)
GEN_IS_SORTED(int32)
GEN_IS_SORTED(int64)

GEN_IS_SORTED_DESC(int8)
GEN_IS_SORTED_DESC(int16)
GEN_IS_SORTED_DESC(int32)
GEN_IS_SORTED_DESC(int64)

// Unsigned integers
GEN_CONTAINS(uint8)
GEN_CONTAINS(uint16)
GEN_CONTAINS(uint32)
GEN_CONTAINS(uint64)

GEN_INDEXOF(uint8)
GEN_INDEXOF(uint16)
GEN_INDEXOF(uint32)
GEN_INDEXOF(uint64)

GEN_LAST_INDEXOF(uint8)
GEN_LAST_INDEXOF(uint16)
GEN_LAST_INDEXOF(uint32)
GEN_LAST_INDEXOF(uint64)

GEN_COUNT(uint8)
GEN_COUNT(uint16)
GEN_COUNT(uint32)
GEN_COUNT(uint64)

GEN_REVERSE(uint8)
GEN_REVERSE(uint16)
GEN_REVERSE(uint32)
GEN_REVERSE(uint64)

GEN_FILL(uint8)
GEN_FILL(uint16)
GEN_FILL(uint32)
GEN_FILL(uint64)

GEN_COPY(uint8)
GEN_COPY(uint16)
GEN_COPY(uint32)
GEN_COPY(uint64)

GEN_EQUALS(uint8)
GEN_EQUALS(uint16)
GEN_EQUALS(uint32)
GEN_EQUALS(uint64)

GEN_MIN_IN_ARRAY(uint8)
GEN_MIN_IN_ARRAY(uint16)
GEN_MIN_IN_ARRAY(uint32)
GEN_MIN_IN_ARRAY(uint64)

GEN_MAX_IN_ARRAY(uint8)
GEN_MAX_IN_ARRAY(uint16)
GEN_MAX_IN_ARRAY(uint32)
GEN_MAX_IN_ARRAY(uint64)

GEN_SUM(uint8)
GEN_SUM(uint16)
GEN_SUM(uint32)
GEN_SUM(uint64)

GEN_IS_SORTED(uint8)
GEN_IS_SORTED(uint16)
GEN_IS_SORTED(uint32)
GEN_IS_SORTED(uint64)

GEN_IS_SORTED_DESC(uint8)
GEN_IS_SORTED_DESC(uint16)
GEN_IS_SORTED_DESC(uint32)
GEN_IS_SORTED_DESC(uint64)

// Floating point types
GEN_CONTAINS(flt32)
GEN_CONTAINS(flt64)

GEN_INDEXOF(flt32)
GEN_INDEXOF(flt64)

GEN_LAST_INDEXOF(flt32)
GEN_LAST_INDEXOF(flt64)

GEN_COUNT(flt32)
GEN_COUNT(flt64)

GEN_REVERSE(flt32)
GEN_REVERSE(flt64)

GEN_FILL(flt32)
GEN_FILL(flt64)

GEN_COPY(flt32)
GEN_COPY(flt64)

GEN_EQUALS(flt32)
GEN_EQUALS(flt64)

GEN_MIN_IN_ARRAY(flt32)
GEN_MIN_IN_ARRAY(flt64)

GEN_MAX_IN_ARRAY(flt32)
GEN_MAX_IN_ARRAY(flt64)

GEN_SUM(flt32)
GEN_SUM(flt64)

GEN_IS_SORTED(flt32)
GEN_IS_SORTED(flt64)

GEN_IS_SORTED_DESC(flt32)
GEN_IS_SORTED_DESC(flt64)

// ============================================================================
// Summary: Collection Functions Generated
// ============================================================================
// 13 functions Ã— 10 types = 130 function variants
//
// Functions per type:
// - contains_T(arr, length, value) -> int8
// - indexOf_T(arr, length, value) -> int64
// - lastIndexOf_T(arr, length, value) -> int64
// - count_T(arr, length, value) -> int64
// - reverse_T(arr, length) -> int8
// - fill_T(arr, length, value) -> int8
// - copy_T(dest, src, length) -> int8
// - equals_T(arr1, arr2, length) -> int8
// - min_in_array_T(arr, length) -> T
// - max_in_array_T(arr, length) -> T
// - sum_T(arr, length) -> T
// - is_sorted_T(arr, length) -> int8
// - is_sorted_desc_T(arr, length) -> int8
//
// Types covered: int8, int16, int32, int64, uint8, uint16, uint32, uint64, flt32, flt64
// ============================================================================
