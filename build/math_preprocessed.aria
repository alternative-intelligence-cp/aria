// ============================================================================
// Aria Standard Library - Math Functions
// ============================================================================
// Core mathematical functions generated for all numeric types using macros
// Demonstrates metaprogramming-driven stdlib development
// ============================================================================

// ----------------------------------------------------------------------------
// Type List Macros - Define once, generate for all types
// ----------------------------------------------------------------------------

// Macro to generate abs() for a single type

// Macro to generate min() for a single type

// Macro to generate max() for a single type

// Macro to generate clamp() for a single type

// ----------------------------------------------------------------------------
// Generate for Signed Integers: int8, int16, int32, int64
// ----------------------------------------------------------------------------


func:abs_int8 = *int8(int8:value) {
    if (value < 0) {
        return 0 - value;
    }
    return value;
};


func:min_int8 = *int8(int8:a, int8:b) {
    if (a < b) {
        return a;
    }
    return b;
};


func:max_int8 = *int8(int8:a, int8:b) {
    if (a > b) {
        return a;
    }
    return b;
};


func:clamp_int8 = *int8(int8:value, int8:min_val, int8:max_val) {
    if (value < min_val) {
        return min_val;
    }
    if (value > max_val) {
        return max_val;
    }
    return value;
};



func:abs_int16 = *int16(int16:value) {
    if (value < 0) {
        return 0 - value;
    }
    return value;
};


func:min_int16 = *int16(int16:a, int16:b) {
    if (a < b) {
        return a;
    }
    return b;
};


func:max_int16 = *int16(int16:a, int16:b) {
    if (a > b) {
        return a;
    }
    return b;
};


func:clamp_int16 = *int16(int16:value, int16:min_val, int16:max_val) {
    if (value < min_val) {
        return min_val;
    }
    if (value > max_val) {
        return max_val;
    }
    return value;
};



func:abs_int32 = *int32(int32:value) {
    if (value < 0) {
        return 0 - value;
    }
    return value;
};


func:min_int32 = *int32(int32:a, int32:b) {
    if (a < b) {
        return a;
    }
    return b;
};


func:max_int32 = *int32(int32:a, int32:b) {
    if (a > b) {
        return a;
    }
    return b;
};


func:clamp_int32 = *int32(int32:value, int32:min_val, int32:max_val) {
    if (value < min_val) {
        return min_val;
    }
    if (value > max_val) {
        return max_val;
    }
    return value;
};



func:abs_int64 = *int64(int64:value) {
    if (value < 0) {
        return 0 - value;
    }
    return value;
};


func:min_int64 = *int64(int64:a, int64:b) {
    if (a < b) {
        return a;
    }
    return b;
};


func:max_int64 = *int64(int64:a, int64:b) {
    if (a > b) {
        return a;
    }
    return b;
};


func:clamp_int64 = *int64(int64:value, int64:min_val, int64:max_val) {
    if (value < min_val) {
        return min_val;
    }
    if (value > max_val) {
        return max_val;
    }
    return value;
};


// ----------------------------------------------------------------------------
// Generate for Unsigned Integers: uint8, uint16, uint32, uint64
// Note: abs() for unsigned is identity function (always positive)
// ----------------------------------------------------------------------------



func:abs_uint8 = *uint8(uint8:value) {
    return value;
};


func:min_uint8 = *uint8(uint8:a, uint8:b) {
    if (a < b) {
        return a;
    }
    return b;
};


func:max_uint8 = *uint8(uint8:a, uint8:b) {
    if (a > b) {
        return a;
    }
    return b;
};


func:clamp_uint8 = *uint8(uint8:value, uint8:min_val, uint8:max_val) {
    if (value < min_val) {
        return min_val;
    }
    if (value > max_val) {
        return max_val;
    }
    return value;
};



func:abs_uint16 = *uint16(uint16:value) {
    return value;
};


func:min_uint16 = *uint16(uint16:a, uint16:b) {
    if (a < b) {
        return a;
    }
    return b;
};


func:max_uint16 = *uint16(uint16:a, uint16:b) {
    if (a > b) {
        return a;
    }
    return b;
};


func:clamp_uint16 = *uint16(uint16:value, uint16:min_val, uint16:max_val) {
    if (value < min_val) {
        return min_val;
    }
    if (value > max_val) {
        return max_val;
    }
    return value;
};



func:abs_uint32 = *uint32(uint32:value) {
    return value;
};


func:min_uint32 = *uint32(uint32:a, uint32:b) {
    if (a < b) {
        return a;
    }
    return b;
};


func:max_uint32 = *uint32(uint32:a, uint32:b) {
    if (a > b) {
        return a;
    }
    return b;
};


func:clamp_uint32 = *uint32(uint32:value, uint32:min_val, uint32:max_val) {
    if (value < min_val) {
        return min_val;
    }
    if (value > max_val) {
        return max_val;
    }
    return value;
};



func:abs_uint64 = *uint64(uint64:value) {
    return value;
};


func:min_uint64 = *uint64(uint64:a, uint64:b) {
    if (a < b) {
        return a;
    }
    return b;
};


func:max_uint64 = *uint64(uint64:a, uint64:b) {
    if (a > b) {
        return a;
    }
    return b;
};


func:clamp_uint64 = *uint64(uint64:value, uint64:min_val, uint64:max_val) {
    if (value < min_val) {
        return min_val;
    }
    if (value > max_val) {
        return max_val;
    }
    return value;
};


// ----------------------------------------------------------------------------
// Generate for Floating Point: flt32, flt64
// ----------------------------------------------------------------------------


func:abs_flt32 = *flt32(flt32:value) {
    if (value < 0) {
        return 0 - value;
    }
    return value;
};


func:min_flt32 = *flt32(flt32:a, flt32:b) {
    if (a < b) {
        return a;
    }
    return b;
};


func:max_flt32 = *flt32(flt32:a, flt32:b) {
    if (a > b) {
        return a;
    }
    return b;
};


func:clamp_flt32 = *flt32(flt32:value, flt32:min_val, flt32:max_val) {
    if (value < min_val) {
        return min_val;
    }
    if (value > max_val) {
        return max_val;
    }
    return value;
};



func:abs_flt64 = *flt64(flt64:value) {
    if (value < 0) {
        return 0 - value;
    }
    return value;
};


func:min_flt64 = *flt64(flt64:a, flt64:b) {
    if (a < b) {
        return a;
    }
    return b;
};


func:max_flt64 = *flt64(flt64:a, flt64:b) {
    if (a > b) {
        return a;
    }
    return b;
};


func:clamp_flt64 = *flt64(flt64:value, flt64:min_val, flt64:max_val) {
    if (value < min_val) {
        return min_val;
    }
    if (value > max_val) {
        return max_val;
    }
    return value;
};


// ----------------------------------------------------------------------------
// Floating Point Math Functions (using LLVM intrinsics)
// ----------------------------------------------------------------------------

// Square root - only for floating point types

// Floor - round down to nearest integer

// Ceil - round up to nearest integer

// Round - round to nearest integer (ties to even)

// Trunc - round toward zero (remove fractional part)

// Power function - x^y

// Generate floating point math functions

func:sqrt_flt32 = *flt32(flt32:value) {
    if (value < 0.0) {
        fail(1);  // Error: negative input
    }
    // LLVM intrinsic: llvm.sqrt.f32/f64
    flt32:result_val = @llvm_sqrt_flt32(value);
    return result_val;
};


func:floor_flt32 = *flt32(flt32:value) {
    // LLVM intrinsic: llvm.floor.f32/f64
    flt32:result_val = @llvm_floor_flt32(value);
    return result_val;
};


func:ceil_flt32 = *flt32(flt32:value) {
    // LLVM intrinsic: llvm.ceil.f32/f64
    flt32:result_val = @llvm_ceil_flt32(value);
    return result_val;
};


func:round_flt32 = *flt32(flt32:value) {
    // LLVM intrinsic: llvm.round.f32/f64
    flt32:result_val = @llvm_round_flt32(value);
    return result_val;
};


func:trunc_flt32 = *flt32(flt32:value) {
    // LLVM intrinsic: llvm.trunc.f32/f64
    flt32:result_val = @llvm_trunc_flt32(value);
    return result_val;
};


func:pow_flt32 = *flt32(flt32:base, flt32:exponent) {
    // LLVM intrinsic: llvm.pow.f32/f64
    flt32:result_val = @llvm_pow_flt32(base, exponent);
    return result_val;
};



func:sqrt_flt64 = *flt64(flt64:value) {
    if (value < 0.0) {
        fail(1);  // Error: negative input
    }
    // LLVM intrinsic: llvm.sqrt.f32/f64
    flt64:result_val = @llvm_sqrt_flt64(value);
    return result_val;
};


func:floor_flt64 = *flt64(flt64:value) {
    // LLVM intrinsic: llvm.floor.f32/f64
    flt64:result_val = @llvm_floor_flt64(value);
    return result_val;
};


func:ceil_flt64 = *flt64(flt64:value) {
    // LLVM intrinsic: llvm.ceil.f32/f64
    flt64:result_val = @llvm_ceil_flt64(value);
    return result_val;
};


func:round_flt64 = *flt64(flt64:value) {
    // LLVM intrinsic: llvm.round.f32/f64
    flt64:result_val = @llvm_round_flt64(value);
    return result_val;
};


func:trunc_flt64 = *flt64(flt64:value) {
    // LLVM intrinsic: llvm.trunc.f32/f64
    flt64:result_val = @llvm_trunc_flt64(value);
    return result_val;
};


func:pow_flt64 = *flt64(flt64:base, flt64:exponent) {
    // LLVM intrinsic: llvm.pow.f32/f64
    flt64:result_val = @llvm_pow_flt64(base, exponent);
    return result_val;
};


// ----------------------------------------------------------------------------
// Integer Power Function (for int types without floating point)
// ----------------------------------------------------------------------------


// Generate integer power functions

func:pow_int8 = *int8(int8:base, int8:exponent) {
    if (exponent < 0) {
        fail(1);  // Error: negative exponent for integer power
    }
    if (exponent == 0) {
        return 1;  // x^0 = 1
    }
    int8:result_val = 1;
    int8:i = 0;
    while (i < exponent) {
        result_val = result_val * base;
        i = i + 1;
    }
    return result_val;
};


func:pow_int16 = *int16(int16:base, int16:exponent) {
    if (exponent < 0) {
        fail(1);  // Error: negative exponent for integer power
    }
    if (exponent == 0) {
        return 1;  // x^0 = 1
    }
    int16:result_val = 1;
    int16:i = 0;
    while (i < exponent) {
        result_val = result_val * base;
        i = i + 1;
    }
    return result_val;
};


func:pow_int32 = *int32(int32:base, int32:exponent) {
    if (exponent < 0) {
        fail(1);  // Error: negative exponent for integer power
    }
    if (exponent == 0) {
        return 1;  // x^0 = 1
    }
    int32:result_val = 1;
    int32:i = 0;
    while (i < exponent) {
        result_val = result_val * base;
        i = i + 1;
    }
    return result_val;
};


func:pow_int64 = *int64(int64:base, int64:exponent) {
    if (exponent < 0) {
        fail(1);  // Error: negative exponent for integer power
    }
    if (exponent == 0) {
        return 1;  // x^0 = 1
    }
    int64:result_val = 1;
    int64:i = 0;
    while (i < exponent) {
        result_val = result_val * base;
        i = i + 1;
    }
    return result_val;
};


func:pow_uint8 = *uint8(uint8:base, uint8:exponent) {
    if (exponent < 0) {
        fail(1);  // Error: negative exponent for integer power
    }
    if (exponent == 0) {
        return 1;  // x^0 = 1
    }
    uint8:result_val = 1;
    uint8:i = 0;
    while (i < exponent) {
        result_val = result_val * base;
        i = i + 1;
    }
    return result_val;
};


func:pow_uint16 = *uint16(uint16:base, uint16:exponent) {
    if (exponent < 0) {
        fail(1);  // Error: negative exponent for integer power
    }
    if (exponent == 0) {
        return 1;  // x^0 = 1
    }
    uint16:result_val = 1;
    uint16:i = 0;
    while (i < exponent) {
        result_val = result_val * base;
        i = i + 1;
    }
    return result_val;
};


func:pow_uint32 = *uint32(uint32:base, uint32:exponent) {
    if (exponent < 0) {
        fail(1);  // Error: negative exponent for integer power
    }
    if (exponent == 0) {
        return 1;  // x^0 = 1
    }
    uint32:result_val = 1;
    uint32:i = 0;
    while (i < exponent) {
        result_val = result_val * base;
        i = i + 1;
    }
    return result_val;
};


func:pow_uint64 = *uint64(uint64:base, uint64:exponent) {
    if (exponent < 0) {
        fail(1);  // Error: negative exponent for integer power
    }
    if (exponent == 0) {
        return 1;  // x^0 = 1
    }
    uint64:result_val = 1;
    uint64:i = 0;
    while (i < exponent) {
        result_val = result_val * base;
        i = i + 1;
    }
    return result_val;
};


// ----------------------------------------------------------------------------
// Integer Square Root (for int types)
// Using Newton's method for integer approximation
// ----------------------------------------------------------------------------


// Generate for signed integers

func:isqrt_int8 = *int8(int8:n) {
    if (n < 0) {
        fail(1);  // Error: negative input
    }
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    
    // Newton's method for integer sqrt
    int8:x = n;
    int8:y = 0;
    while (y != x) {
        y = x;
        x = (x + (n / x)) / 2;
    }
    return x;
};


func:isqrt_int16 = *int16(int16:n) {
    if (n < 0) {
        fail(1);  // Error: negative input
    }
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    
    // Newton's method for integer sqrt
    int16:x = n;
    int16:y = 0;
    while (y != x) {
        y = x;
        x = (x + (n / x)) / 2;
    }
    return x;
};


func:isqrt_int32 = *int32(int32:n) {
    if (n < 0) {
        fail(1);  // Error: negative input
    }
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    
    // Newton's method for integer sqrt
    int32:x = n;
    int32:y = 0;
    while (y != x) {
        y = x;
        x = (x + (n / x)) / 2;
    }
    return x;
};


func:isqrt_int64 = *int64(int64:n) {
    if (n < 0) {
        fail(1);  // Error: negative input
    }
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    
    // Newton's method for integer sqrt
    int64:x = n;
    int64:y = 0;
    while (y != x) {
        y = x;
        x = (x + (n / x)) / 2;
    }
    return x;
};


// For unsigned, always valid input


func:isqrt_uint8 = *uint8(uint8:n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    
    uint8:x = n;
    uint8:y = 0;
    while (y != x) {
        y = x;
        x = (x + (n / x)) / 2;
    }
    return x;
};


func:isqrt_uint16 = *uint16(uint16:n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    
    uint16:x = n;
    uint16:y = 0;
    while (y != x) {
        y = x;
        x = (x + (n / x)) / 2;
    }
    return x;
};


func:isqrt_uint32 = *uint32(uint32:n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    
    uint32:x = n;
    uint32:y = 0;
    while (y != x) {
        y = x;
        x = (x + (n / x)) / 2;
    }
    return x;
};


func:isqrt_uint64 = *uint64(uint64:n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    
    uint64:x = n;
    uint64:y = 0;
    while (y != x) {
        y = x;
        x = (x + (n / x)) / 2;
    }
    return x;
};


// ============================================================================
// Summary:
// Basic functions: 4 functions × 14 types = 56 variants
// Float math: 6 functions × 2 types = 12 variants (sqrt, floor, ceil, round, trunc, pow)
// Integer power: 1 function × 8 types = 8 variants
// Integer sqrt: 1 function × 8 types = 8 variants
// Total: 84 function variants from ~15 macro definitions
// - Type-safe, no runtime overhead
// - Demonstrating macro-driven stdlib development with LLVM intrinsics
// ============================================================================

func:main = *int8() { return 0; };
