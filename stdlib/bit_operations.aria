// ============================================================================
// Aria Standard Library - Bit Manipulation Functions
// ============================================================================
// Bitwise operations, bit counting, rotation, and manipulation
// Generated for all integer types using macros
// ============================================================================

%macro GEN_BIT_UTILS 2
    // Count number of set bits (population count / Hamming weight)
    func:popcount_%1 = *int32(%1:x) {
        int32:count = 0;
        %1:val = x;
        int32:i = 0;
        
        while (i < %2) {
            if ((val & 1) != 0) {
                count = count + 1;
            }
            val = val >> 1;
            i = i + 1;
        }
        
        return count;
    };
    
    // Count leading zeros (CLZ)
    func:clz_%1 = *int32(%1:x) {
        if (x == 0) {
            return %2;
        }
        
        int32:count = 0;
        %1:mask = 1 << (%2 - 1);
        
        while ((x & mask) == 0) {
            count = count + 1;
            mask = mask >> 1;
        }
        
        return count;
    };
    
    // Count trailing zeros (CTZ)
    func:ctz_%1 = *int32(%1:x) {
        if (x == 0) {
            return %2;
        }
        
        int32:count = 0;
        %1:val = x;
        
        while ((val & 1) == 0) {
            count = count + 1;
            val = val >> 1;
        }
        
        return count;
    };
    
    // Find first set bit (1-indexed, 0 if none)
    func:ffs_%1 = *int32(%1:x) {
        if (x == 0) {
            return 0;
        }
        
        int32:pos = ctz_%1(x) ? 0;
        return pos + 1;
    };
    
    // Find last set bit (1-indexed, 0 if none)
    func:fls_%1 = *int32(%1:x) {
        if (x == 0) {
            return 0;
        }
        
        int32:lz = clz_%1(x) ? 0;
        return %2 - lz;
    };
    
    // Reverse bits
    func:reverse_bits_%1 = *%1(%1:x) {
        %1:rev = 0;
        %1:val = x;
        int32:i = 0;
        
        while (i < %2) {
            rev = rev << 1;
            rev = rev | (val & 1);
            val = val >> 1;
            i = i + 1;
        }
        
        return rev;
    };
    
    // Rotate left
    func:rotl_%1 = *%1(%1:x, int32:n) {
        int32:shift = n % %2;
        if (shift == 0) {
            return x;
        }
        
        %1:left = x << shift;
        %1:right = x >> (%2 - shift);
        return left | right;
    };
    
    // Rotate right
    func:rotr_%1 = *%1(%1:x, int32:n) {
        int32:shift = n % %2;
        if (shift == 0) {
            return x;
        }
        
        %1:right = x >> shift;
        %1:left = x << (%2 - shift);
        return right | left;
    };
    
    // Check if bit at position is set
    func:bit_test_%1 = *int8(%1:x, int32:pos) {
        if (pos < 0) {
            return 0;
        }
        if (pos >= %2) {
            return 0;
        }
        
        %1:mask = 1 << pos;
        if ((x & mask) != 0) {
            return 1;
        }
        return 0;
    };
    
    // Set bit at position
    func:bit_set_%1 = *%1(%1:x, int32:pos) {
        if (pos < 0) {
            return x;
        }
        if (pos >= %2) {
            return x;
        }
        
        %1:mask = 1 << pos;
        return x | mask;
    };
    
    // Clear bit at position
    func:bit_clear_%1 = *%1(%1:x, int32:pos) {
        if (pos < 0) {
            return x;
        }
        if (pos >= %2) {
            return x;
        }
        
        %1:mask = 1 << pos;
        return x & (~mask);
    };
    
    // Toggle bit at position
    func:bit_toggle_%1 = *%1(%1:x, int32:pos) {
        if (pos < 0) {
            return x;
        }
        if (pos >= %2) {
            return x;
        }
        
        %1:mask = 1 << pos;
        return x ^ mask;
    };
    
    // Extract bits from range [start, end)
    func:bit_extract_%1 = *%1(%1:x, int32:start, int32:len) {
        if (start < 0) {
            return 0;
        }
        if (len <= 0) {
            return 0;
        }
        if (start >= %2) {
            return 0;
        }
        
        // Calculate actual length
        int32:actual_len = len;
        if (start + len > %2) {
            actual_len = %2 - start;
        }
        
        // Shift right to position
        %1:shifted = x >> start;
        
        // Create mask for length
        %1:mask = (1 << actual_len) - 1;
        
        return shifted & mask;
    };
    
    // Check if power of 2
    func:is_power_of_2_%1 = *int8(%1:x) {
        if (x == 0) {
            return 0;
        }
        
        %1:res = x & (x - 1);
        if (res == 0) {
            return 1;
        }
        return 0;
    };
    
    // Round up to next power of 2
    func:next_power_of_2_%1 = *%1(%1:x) {
        if (x == 0) {
            return 1;
        }
        
        // Check if already power of 2
        int8:is_pow2 = is_power_of_2_%1(x) ? 0;
        if (is_pow2 == 1) {
            return x;
        }
        
        %1:val = x - 1;
        int32:i = 1;
        
        while (i < %2) {
            val = val | (val >> i);
            i = i * 2;
        }
        
        return val + 1;
    };
    
    // Parity (1 if odd number of set bits, 0 if even)
    func:parity_%1 = *int8(%1:x) {
        int32:count = popcount_%1(x) ? 0;
        return count & 1;
    };
%endmacro

// Generate for all integer types
GEN_BIT_UTILS(int8, 8)
GEN_BIT_UTILS(int16, 16)
GEN_BIT_UTILS(int32, 32)
GEN_BIT_UTILS(int64, 64)
GEN_BIT_UTILS(uint8, 8)
GEN_BIT_UTILS(uint16, 16)
GEN_BIT_UTILS(uint32, 32)
GEN_BIT_UTILS(uint64, 64)

// ============================================================================
// BIT MANIPULATION SUMMARY
// ============================================================================
// Generated Functions (17 functions Ã— 8 types = 136 total):
//
// 1. popcount_T(x) - Count set bits (population count)
// 2. clz_T(x) - Count leading zeros
// 3. ctz_T(x) - Count trailing zeros
// 4. ffs_T(x) - Find first set bit (1-indexed)
// 5. fls_T(x) - Find last set bit (1-indexed)
// 6. reverse_bits_T(x) - Reverse all bits
// 7. rotl_T(x, n) - Rotate left by n positions
// 8. rotr_T(x, n) - Rotate right by n positions
// 9. bit_test_T(x, pos) - Test if bit at position is set
// 10. bit_set_T(x, pos) - Set bit at position
// 11. bit_clear_T(x, pos) - Clear bit at position
// 12. bit_toggle_T(x, pos) - Toggle bit at position
// 13. bit_extract_T(x, start, len) - Extract bit range
// 14. is_power_of_2_T(x) - Check if power of 2
// 15. next_power_of_2_T(x) - Round up to next power of 2
// 16. parity_T(x) - Calculate parity bit
//
// Types: int8, int16, int32, int64, uint8, uint16, uint32, uint64
// ============================================================================

func:main = *int8() {
    puts("Bit Operations Library: 136 functions compiled successfully!");
    return 0;
};
