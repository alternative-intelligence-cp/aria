func:floor_flt32 = *flt32(flt32:value) {
    // LLVM intrinsic: llvm.floor.f32/f64
    flt32:result_val = @llvm_floor_flt32(value);
    return result_val;
};


func:ceil_flt32 = *flt32(flt32:value) {
    // LLVM intrinsic: llvm.ceil.f32/f64
    flt32:result_val = @llvm_ceil_flt32(value);
    return result_val;
};


func:round_flt32 = *flt32(flt32:value) {
    // LLVM intrinsic: llvm.round.f32/f64
    flt32:result_val = @llvm_round_flt32(value);
    return result_val;
};


func:trunc_flt32 = *flt32(flt32:value) {
    // LLVM intrinsic: llvm.trunc.f32/f64
    flt32:result_val = @llvm_trunc_flt32(value);
    return result_val;
};


func:pow_flt32 = *flt32(flt32:base, flt32:exponent) {
    // LLVM intrinsic: llvm.pow.f32/f64
    flt32:result_val = @llvm_pow_flt32(base, exponent);
    return result_val;
};



func:sqrt_flt64 = *flt64(flt64:value) {
    if (value < 0.0) {
        fail(1);  // Error: negative input
    }
    // LLVM intrinsic: llvm.sqrt.f32/f64
    flt64:result_val = @llvm_sqrt_flt64(value);
    return result_val;
};


func:floor_flt64 = *flt64(flt64:value) {
    // LLVM intrinsic: llvm.floor.f32/f64
    flt64:result_val = @llvm_floor_flt64(value);
    return result_val;
};


func:ceil_flt64 = *flt64(flt64:value) {
    // LLVM intrinsic: llvm.ceil.f32/f64
    flt64:result_val = @llvm_ceil_flt64(value);
    return result_val;
};


func:round_flt64 = *flt64(flt64:value) {
    // LLVM intrinsic: llvm.round.f32/f64
    flt64:result_val = @llvm_round_flt64(value);
    return result_val;
};


func:trunc_flt64 = *flt64(flt64:value) {
    // LLVM intrinsic: llvm.trunc.f32/f64
    flt64:result_val = @llvm_trunc_flt64(value);
    return result_val;
};


func:pow_flt64 = *flt64(flt64:base, flt64:exponent) {
    // LLVM intrinsic: llvm.pow.f32/f64
    flt64:result_val = @llvm_pow_flt64(base, exponent);
    return result_val;
};


// ----------------------------------------------------------------------------
// Integer Power Function (for int types without floating point)
// ----------------------------------------------------------------------------


// Generate integer power functions

func:pow_int8 = *int8(int8:base, int8:exponent) {
    if (exponent < 0) {
        fail(1);  // Error: negative exponent for integer power
    }
    if (exponent == 0) {
        return 1;  // x^0 = 1
    }
    int8:result_val = 1;
    int8:i = 0;
    while (i < exponent) {
        result_val = result_val * base;
        i = i + 1;
    }
    return result_val;
};


func:pow_int16 = *int16(int16:base, int16:exponent) {
    if (exponent < 0) {
        fail(1);  // Error: negative exponent for integer power
    }
    if (exponent == 0) {
        return 1;  // x^0 = 1
    }
    int16:result_val = 1;
    int16:i = 0;
    while (i < exponent) {
        result_val = result_val * base;
        i = i + 1;
    }
    return result_val;
};


func:pow_int32 = *int32(int32:base, int32:exponent) {
    if (exponent < 0) {
        fail(1);  // Error: negative exponent for integer power
    }
    if (exponent == 0) {
        return 1;  // x^0 = 1
    }
    int32:result_val = 1;
    int32:i = 0;
    while (i < exponent) {
        result_val = result_val * base;
        i = i + 1;
    }
    return result_val;
};


func:pow_int64 = *int64(int64:base, int64:exponent) {
    if (exponent < 0) {
        fail(1);  // Error: negative exponent for integer power
    }
    if (exponent == 0) {
        return 1;  // x^0 = 1
    }
    int64:result_val = 1;
    int64:i = 0;
    while (i < exponent) {
        result_val = result_val * base;
        i = i + 1;
    }
    return result_val;
};


func:pow_uint8 = *uint8(uint8:base, uint8:exponent) {
    if (exponent < 0) {
        fail(1);  // Error: negative exponent for integer power
    }
    if (exponent == 0) {
        return 1;  // x^0 = 1
    }
    uint8:result_val = 1;
    uint8:i = 0;
    while (i < exponent) {
        result_val = result_val * base;
        i = i + 1;
    }
    return result_val;
};


func:pow_uint16 = *uint16(uint16:base, uint16:exponent) {
    if (exponent < 0) {
        fail(1);  // Error: negative exponent for integer power
    }
    if (exponent == 0) {
        return 1;  // x^0 = 1
    }
    uint16:result_val = 1;
    uint16:i = 0;
    while (i < exponent) {
        result_val = result_val * base;
        i = i + 1;
    }
    return result_val;
};


func:pow_uint32 = *uint32(uint32:base, uint32:exponent) {
    if (exponent < 0) {
        fail(1);  // Error: negative exponent for integer power
    }
    if (exponent == 0) {
        return 1;  // x^0 = 1
    }
    uint32:result_val = 1;
    uint32:i = 0;
    while (i < exponent) {
        result_val = result_val * base;
        i = i + 1;
    }
    return result_val;
};


func:pow_uint64 = *uint64(uint64:base, uint64:exponent) {
    if (exponent < 0) {
        fail(1);  // Error: negative exponent for integer power
    }
    if (exponent == 0) {
        return 1;  // x^0 = 1
    }
    uint64:result_val = 1;
    uint64:i = 0;
    while (i < exponent) {
        result_val = result_val * base;
        i = i + 1;
    }
    return result_val;
};


// ----------------------------------------------------------------------------
// Integer Square Root (for int types)
// Using Newton's method for integer approximation
// ----------------------------------------------------------------------------


// Generate for signed integers

func:isqrt_int8 = *int8(int8:n) {
    if (n < 0) {
        fail(1);  // Error: negative input
    }
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    
    // Newton's method for integer sqrt
    int8:x = n;
    int8:y = 0;
    while (y != x) {
        y = x;
        x = (x + (n / x)) / 2;
    }
    return x;
};


func:isqrt_int16 = *int16(int16:n) {
    if (n < 0) {
        fail(1);  // Error: negative input
    }
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    
    // Newton's method for integer sqrt
    int16:x = n;
    int16:y = 0;
    while (y != x) {
        y = x;
        x = (x + (n / x)) / 2;
    }
    return x;
};


func:isqrt_int32 = *int32(int32:n) {
    if (n < 0) {
        fail(1);  // Error: negative input
    }
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    
    // Newton's method for integer sqrt
    int32:x = n;
    int32:y = 0;
    while (y != x) {
        y = x;
        x = (x + (n / x)) / 2;
    }
    return x;
};


func:isqrt_int64 = *int64(int64:n) {
    if (n < 0) {
        fail(1);  // Error: negative input
    }
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    
    // Newton's method for integer sqrt
    int64:x = n;
    int64:y = 0;
    while (y != x) {
        y = x;
        x = (x + (n / x)) / 2;
    }
    return x;
};


// For unsigned, always valid input


func:isqrt_uint8 = *uint8(uint8:n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    
    uint8:x = n;
    uint8:y = 0;
    while (y != x) {
        y = x;
        x = (x + (n / x)) / 2;
    }
    return x;
};


func:isqrt_uint16 = *uint16(uint16:n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    
    uint16:x = n;
    uint16:y = 0;
    while (y != x) {
        y = x;
        x = (x + (n / x)) / 2;
    }
    return x;
};


func:isqrt_uint32 = *uint32(uint32:n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    
    uint32:x = n;
    uint32:y = 0;
    while (y != x) {
        y = x;
        x = (x + (n / x)) / 2;
    }
    return x;
};


func:isqrt_uint64 = *uint64(uint64:n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    
    uint64:x = n;
    uint64:y = 0;
    while (y != x) {
        y = x;
        x = (x + (n / x)) / 2;
    }
    return x;
};


// ============================================================================
// Summary:
// Basic functions: 4 functions × 14 types = 56 variants
// Float math: 6 functions × 2 types = 12 variants (sqrt, floor, ceil, round, trunc, pow)
// Integer power: 1 function × 8 types = 8 variants
// Integer sqrt: 1 function × 8 types = 8 variants
// Total: 84 function variants from ~15 macro definitions
// - Type-safe, no runtime overhead
// - Demonstrating macro-driven stdlib development with LLVM intrinsics
// ============================================================================

func:main = *int8() { return 0; };

func:main = *int8() { return 0; };
