// ============================================================================
// Aria Standard Library - Bit Manipulation Functions
// ============================================================================
// Bitwise operations, bit counting, rotation, and manipulation
// Generated for all integer types using macros
// ============================================================================


// Generate for all integer types

    // Count number of set bits (population count / Hamming weight)
    func:popcount_int8 = *int32(int8:x) {
        int32:count = 0;
        int8:val = x;
        int32:i = 0;
        
        while (i < 8) {
            if ((val & 1) != 0) {
                count = count + 1;
            }
            val = val >> 1;
            i = i + 1;
        }
        
        return count;
    };
    
    // Count leading zeros (CLZ)
    func:clz_int8 = *int32(int8:x) {
        if (x == 0) {
            return 8;
        }
        
        int32:count = 0;
        int8:mask = 1 << (8 - 1);
        
        while ((x & mask) == 0) {
            count = count + 1;
            mask = mask >> 1;
        }
        
        return count;
    };
    
    // Count trailing zeros (CTZ)
    func:ctz_int8 = *int32(int8:x) {
        if (x == 0) {
            return 8;
        }
        
        int32:count = 0;
        int8:val = x;
        
        while ((val & 1) == 0) {
            count = count + 1;
            val = val >> 1;
        }
        
        return count;
    };
    
    // Find first set bit (1-indexed, 0 if none)
    func:ffs_int8 = *int32(int8:x) {
        if (x == 0) {
            return 0;
        }
        
        int32:pos = ctz_int8(x) ? 0;
        return pos + 1;
    };
    
    // Find last set bit (1-indexed, 0 if none)
    func:fls_int8 = *int32(int8:x) {
        if (x == 0) {
            return 0;
        }
        
        int32:lz = clz_int8(x) ? 0;
        return 8 - lz;
    };
    
    // Reverse bits
    func:reverse_bits_int8 = *int8(int8:x) {
        int8:rev = 0;
        int8:val = x;
        int32:i = 0;
        
        while (i < 8) {
            rev = rev << 1;
            rev = rev | (val & 1);
            val = val >> 1;
            i = i + 1;
        }
        
        return rev;
    };
    
    // Rotate left
    func:rotl_int8 = *int8(int8:x, int32:n) {
        int32:shift = n % 8;
        if (shift == 0) {
            return x;
        }
        
        int8:left = x << shift;
        int8:right = x >> (8 - shift);
        return left | right;
    };
    
    // Rotate right
    func:rotr_int8 = *int8(int8:x, int32:n) {
        int32:shift = n % 8;
        if (shift == 0) {
            return x;
        }
        
        int8:right = x >> shift;
        int8:left = x << (8 - shift);
        return right | left;
    };
    
    // Check if bit at position is set
    func:bit_test_int8 = *int8(int8:x, int32:pos) {
        if (pos < 0) {
            return 0;
        }
        if (pos >= 8) {
            return 0;
        }
        
        int8:mask = 1 << pos;
        if ((x & mask) != 0) {
            return 1;
        }
        return 0;
    };
    
    // Set bit at position
    func:bit_set_int8 = *int8(int8:x, int32:pos) {
        if (pos < 0) {
            return x;
        }
        if (pos >= 8) {
            return x;
        }
        
        int8:mask = 1 << pos;
        return x | mask;
    };
    
    // Clear bit at position
    func:bit_clear_int8 = *int8(int8:x, int32:pos) {
        if (pos < 0) {
            return x;
        }
        if (pos >= 8) {
            return x;
        }
        
        int8:mask = 1 << pos;
        return x & (~mask);
    };
    
    // Toggle bit at position
    func:bit_toggle_int8 = *int8(int8:x, int32:pos) {
        if (pos < 0) {
            return x;
        }
        if (pos >= 8) {
            return x;
        }
        
        int8:mask = 1 << pos;
        return x ^ mask;
    };
    
    // Extract bits from range [start, end)
    func:bit_extract_int8 = *int8(int8:x, int32:start, int32:len) {
        if (start < 0) {
            return 0;
        }
        if (len <= 0) {
            return 0;
        }
        if (start >= 8) {
            return 0;
        }
        
        // Calculate actual length
        int32:actual_len = len;
        if (start + len > 8) {
            actual_len = 8 - start;
        }
        
        // Shift right to position
        int8:shifted = x >> start;
        
        // Create mask for length
        int8:mask = (1 << actual_len) - 1;
        
        return shifted & mask;
    };
    
    // Check if power of 2
    func:is_power_of_2_int8 = *int8(int8:x) {
        if (x == 0) {
            return 0;
        }
        
        int8:res = x & (x - 1);
        if (res == 0) {
            return 1;
        }
        return 0;
    };
    
    // Round up to next power of 2
    func:next_power_of_2_int8 = *int8(int8:x) {
        if (x == 0) {
            return 1;
        }
        
        // Check if already power of 2
        int8:is_pow2 = is_power_of_2_int8(x) ? 0;
        if (is_pow2 == 1) {
            return x;
        }
        
        int8:val = x - 1;
        int32:i = 1;
        
        while (i < 8) {
            val = val | (val >> i);
            i = i * 2;
        }
        
        return val + 1;
    };
    
    // Parity (1 if odd number of set bits, 0 if even)
    func:parity_int8 = *int8(int8:x) {
        int32:count = popcount_int8(x) ? 0;
        return count & 1;
    };


    // Count number of set bits (population count / Hamming weight)
    func:popcount_int16 = *int32(int16:x) {
        int32:count = 0;
        int16:val = x;
        int32:i = 0;
        
        while (i < 16) {
            if ((val & 1) != 0) {
                count = count + 1;
            }
            val = val >> 1;
            i = i + 1;
        }
        
        return count;
    };
    
    // Count leading zeros (CLZ)
    func:clz_int16 = *int32(int16:x) {
        if (x == 0) {
            return 16;
        }
        
        int32:count = 0;
        int16:mask = 1 << (16 - 1);
        
        while ((x & mask) == 0) {
            count = count + 1;
            mask = mask >> 1;
        }
        
        return count;
    };
    
    // Count trailing zeros (CTZ)
    func:ctz_int16 = *int32(int16:x) {
        if (x == 0) {
            return 16;
        }
        
        int32:count = 0;
        int16:val = x;
        
        while ((val & 1) == 0) {
            count = count + 1;
            val = val >> 1;
        }
        
        return count;
    };
    
    // Find first set bit (1-indexed, 0 if none)
    func:ffs_int16 = *int32(int16:x) {
        if (x == 0) {
            return 0;
        }
        
        int32:pos = ctz_int16(x) ? 0;
        return pos + 1;
    };
    
    // Find last set bit (1-indexed, 0 if none)
    func:fls_int16 = *int32(int16:x) {
        if (x == 0) {
            return 0;
        }
        
        int32:lz = clz_int16(x) ? 0;
        return 16 - lz;
    };
    
    // Reverse bits
    func:reverse_bits_int16 = *int16(int16:x) {
        int16:rev = 0;
        int16:val = x;
        int32:i = 0;
        
        while (i < 16) {
            rev = rev << 1;
            rev = rev | (val & 1);
            val = val >> 1;
            i = i + 1;
        }
        
        return rev;
    };
    
    // Rotate left
    func:rotl_int16 = *int16(int16:x, int32:n) {
        int32:shift = n % 16;
        if (shift == 0) {
            return x;
        }
        
        int16:left = x << shift;
        int16:right = x >> (16 - shift);
        return left | right;
    };
    
    // Rotate right
    func:rotr_int16 = *int16(int16:x, int32:n) {
        int32:shift = n % 16;
        if (shift == 0) {
            return x;
        }
        
        int16:right = x >> shift;
        int16:left = x << (16 - shift);
        return right | left;
    };
    
    // Check if bit at position is set
    func:bit_test_int16 = *int8(int16:x, int32:pos) {
        if (pos < 0) {
            return 0;
        }
        if (pos >= 16) {
            return 0;
        }
        
        int16:mask = 1 << pos;
        if ((x & mask) != 0) {
            return 1;
        }
        return 0;
    };
    
    // Set bit at position
    func:bit_set_int16 = *int16(int16:x, int32:pos) {
        if (pos < 0) {
            return x;
        }
        if (pos >= 16) {
            return x;
        }
        
        int16:mask = 1 << pos;
        return x | mask;
    };
    
    // Clear bit at position
    func:bit_clear_int16 = *int16(int16:x, int32:pos) {
        if (pos < 0) {
            return x;
        }
        if (pos >= 16) {
            return x;
        }
        
        int16:mask = 1 << pos;
        return x & (~mask);
    };
    
    // Toggle bit at position
    func:bit_toggle_int16 = *int16(int16:x, int32:pos) {
        if (pos < 0) {
            return x;
        }
        if (pos >= 16) {
            return x;
        }
        
        int16:mask = 1 << pos;
        return x ^ mask;
    };
    
    // Extract bits from range [start, end)
    func:bit_extract_int16 = *int16(int16:x, int32:start, int32:len) {
        if (start < 0) {
            return 0;
        }
        if (len <= 0) {
            return 0;
        }
        if (start >= 16) {
            return 0;
        }
        
        // Calculate actual length
        int32:actual_len = len;
        if (start + len > 16) {
            actual_len = 16 - start;
        }
        
        // Shift right to position
        int16:shifted = x >> start;
        
        // Create mask for length
        int16:mask = (1 << actual_len) - 1;
        
        return shifted & mask;
    };
    
    // Check if power of 2
    func:is_power_of_2_int16 = *int8(int16:x) {
        if (x == 0) {
            return 0;
        }
        
        int16:res = x & (x - 1);
        if (res == 0) {
            return 1;
        }
        return 0;
    };
    
    // Round up to next power of 2
    func:next_power_of_2_int16 = *int16(int16:x) {
        if (x == 0) {
            return 1;
        }
        
        // Check if already power of 2
        int8:is_pow2 = is_power_of_2_int16(x) ? 0;
        if (is_pow2 == 1) {
            return x;
        }
        
        int16:val = x - 1;
        int32:i = 1;
        
        while (i < 16) {
            val = val | (val >> i);
            i = i * 2;
        }
        
        return val + 1;
    };
    
    // Parity (1 if odd number of set bits, 0 if even)
    func:parity_int16 = *int8(int16:x) {
        int32:count = popcount_int16(x) ? 0;
        return count & 1;
    };


    // Count number of set bits (population count / Hamming weight)
    func:popcount_int32 = *int32(int32:x) {
        int32:count = 0;
        int32:val = x;
        int32:i = 0;
        
        while (i < 32) {
            if ((val & 1) != 0) {
                count = count + 1;
            }
            val = val >> 1;
            i = i + 1;
        }
        
        return count;
    };
    
    // Count leading zeros (CLZ)
    func:clz_int32 = *int32(int32:x) {
        if (x == 0) {
            return 32;
        }
        
        int32:count = 0;
        int32:mask = 1 << (32 - 1);
        
        while ((x & mask) == 0) {
            count = count + 1;
            mask = mask >> 1;
        }
        
        return count;
    };
    
    // Count trailing zeros (CTZ)
    func:ctz_int32 = *int32(int32:x) {
        if (x == 0) {
            return 32;
        }
        
        int32:count = 0;
        int32:val = x;
        
        while ((val & 1) == 0) {
            count = count + 1;
            val = val >> 1;
        }
        
        return count;
    };
    
    // Find first set bit (1-indexed, 0 if none)
    func:ffs_int32 = *int32(int32:x) {
        if (x == 0) {
            return 0;
        }
        
        int32:pos = ctz_int32(x) ? 0;
        return pos + 1;
    };
    
    // Find last set bit (1-indexed, 0 if none)
    func:fls_int32 = *int32(int32:x) {
        if (x == 0) {
            return 0;
        }
        
        int32:lz = clz_int32(x) ? 0;
        return 32 - lz;
    };
    
    // Reverse bits
    func:reverse_bits_int32 = *int32(int32:x) {
        int32:rev = 0;
        int32:val = x;
        int32:i = 0;
        
        while (i < 32) {
            rev = rev << 1;
            rev = rev | (val & 1);
            val = val >> 1;
            i = i + 1;
        }
        
        return rev;
    };
    
    // Rotate left
    func:rotl_int32 = *int32(int32:x, int32:n) {
        int32:shift = n % 32;
        if (shift == 0) {
            return x;
        }
        
        int32:left = x << shift;
        int32:right = x >> (32 - shift);
        return left | right;
    };
    
    // Rotate right
    func:rotr_int32 = *int32(int32:x, int32:n) {
        int32:shift = n % 32;
        if (shift == 0) {
            return x;
        }
        
        int32:right = x >> shift;
        int32:left = x << (32 - shift);
        return right | left;
    };
    
    // Check if bit at position is set
    func:bit_test_int32 = *int8(int32:x, int32:pos) {
        if (pos < 0) {
            return 0;
        }
        if (pos >= 32) {
            return 0;
        }
        
        int32:mask = 1 << pos;
        if ((x & mask) != 0) {
            return 1;
        }
        return 0;
    };
    
    // Set bit at position
    func:bit_set_int32 = *int32(int32:x, int32:pos) {
        if (pos < 0) {
            return x;
        }
        if (pos >= 32) {
            return x;
        }
        
        int32:mask = 1 << pos;
        return x | mask;
    };
    
    // Clear bit at position
    func:bit_clear_int32 = *int32(int32:x, int32:pos) {
        if (pos < 0) {
            return x;
        }
        if (pos >= 32) {
            return x;
        }
        
        int32:mask = 1 << pos;
        return x & (~mask);
    };
    
    // Toggle bit at position
    func:bit_toggle_int32 = *int32(int32:x, int32:pos) {
        if (pos < 0) {
            return x;
        }
        if (pos >= 32) {
            return x;
        }
        
        int32:mask = 1 << pos;
        return x ^ mask;
    };
    
    // Extract bits from range [start, end)
    func:bit_extract_int32 = *int32(int32:x, int32:start, int32:len) {
        if (start < 0) {
            return 0;
        }
        if (len <= 0) {
            return 0;
        }
        if (start >= 32) {
            return 0;
        }
        
        // Calculate actual length
        int32:actual_len = len;
        if (start + len > 32) {
            actual_len = 32 - start;
        }
        
        // Shift right to position
        int32:shifted = x >> start;
        
        // Create mask for length
        int32:mask = (1 << actual_len) - 1;
        
        return shifted & mask;
    };
    
    // Check if power of 2
    func:is_power_of_2_int32 = *int8(int32:x) {
        if (x == 0) {
            return 0;
        }
        
        int32:res = x & (x - 1);
        if (res == 0) {
            return 1;
        }
        return 0;
    };
    
    // Round up to next power of 2
    func:next_power_of_2_int32 = *int32(int32:x) {
        if (x == 0) {
            return 1;
        }
        
        // Check if already power of 2
        int8:is_pow2 = is_power_of_2_int32(x) ? 0;
        if (is_pow2 == 1) {
            return x;
        }
        
        int32:val = x - 1;
        int32:i = 1;
        
        while (i < 32) {
            val = val | (val >> i);
            i = i * 2;
        }
        
        return val + 1;
    };
    
    // Parity (1 if odd number of set bits, 0 if even)
    func:parity_int32 = *int8(int32:x) {
        int32:count = popcount_int32(x) ? 0;
        return count & 1;
    };


    // Count number of set bits (population count / Hamming weight)
    func:popcount_int64 = *int32(int64:x) {
        int32:count = 0;
        int64:val = x;
        int32:i = 0;
        
        while (i < 64) {
            if ((val & 1) != 0) {
                count = count + 1;
            }
            val = val >> 1;
            i = i + 1;
        }
        
        return count;
    };
    
    // Count leading zeros (CLZ)
    func:clz_int64 = *int32(int64:x) {
        if (x == 0) {
            return 64;
        }
        
        int32:count = 0;
        int64:mask = 1 << (64 - 1);
        
        while ((x & mask) == 0) {
            count = count + 1;
            mask = mask >> 1;
        }
        
        return count;
    };
    
    // Count trailing zeros (CTZ)
    func:ctz_int64 = *int32(int64:x) {
        if (x == 0) {
            return 64;
        }
        
        int32:count = 0;
        int64:val = x;
        
        while ((val & 1) == 0) {
            count = count + 1;
            val = val >> 1;
        }
        
        return count;
    };
    
    // Find first set bit (1-indexed, 0 if none)
    func:ffs_int64 = *int32(int64:x) {
        if (x == 0) {
            return 0;
        }
        
        int32:pos = ctz_int64(x) ? 0;
        return pos + 1;
    };
    
    // Find last set bit (1-indexed, 0 if none)
    func:fls_int64 = *int32(int64:x) {
        if (x == 0) {
            return 0;
        }
        
        int32:lz = clz_int64(x) ? 0;
        return 64 - lz;
    };
    
    // Reverse bits
    func:reverse_bits_int64 = *int64(int64:x) {
        int64:rev = 0;
        int64:val = x;
        int32:i = 0;
        
        while (i < 64) {
            rev = rev << 1;
            rev = rev | (val & 1);
            val = val >> 1;
            i = i + 1;
        }
        
        return rev;
    };
    
    // Rotate left
    func:rotl_int64 = *int64(int64:x, int32:n) {
        int32:shift = n % 64;
        if (shift == 0) {
            return x;
        }
        
        int64:left = x << shift;
        int64:right = x >> (64 - shift);
        return left | right;
    };
    
    // Rotate right
    func:rotr_int64 = *int64(int64:x, int32:n) {
        int32:shift = n % 64;
        if (shift == 0) {
            return x;
        }
        
        int64:right = x >> shift;
        int64:left = x << (64 - shift);
        return right | left;
    };
    
    // Check if bit at position is set
    func:bit_test_int64 = *int8(int64:x, int32:pos) {
        if (pos < 0) {
            return 0;
        }
        if (pos >= 64) {
            return 0;
        }
        
        int64:mask = 1 << pos;
        if ((x & mask) != 0) {
            return 1;
        }
        return 0;
    };
    
    // Set bit at position
    func:bit_set_int64 = *int64(int64:x, int32:pos) {
        if (pos < 0) {
            return x;
        }
        if (pos >= 64) {
            return x;
        }
        
        int64:mask = 1 << pos;
        return x | mask;
    };
    
    // Clear bit at position
    func:bit_clear_int64 = *int64(int64:x, int32:pos) {
        if (pos < 0) {
            return x;
        }
        if (pos >= 64) {
            return x;
        }
        
        int64:mask = 1 << pos;
        return x & (~mask);
    };
    
    // Toggle bit at position
    func:bit_toggle_int64 = *int64(int64:x, int32:pos) {
        if (pos < 0) {
            return x;
        }
        if (pos >= 64) {
            return x;
        }
        
        int64:mask = 1 << pos;
        return x ^ mask;
    };
    
    // Extract bits from range [start, end)
    func:bit_extract_int64 = *int64(int64:x, int32:start, int32:len) {
        if (start < 0) {
            return 0;
        }
        if (len <= 0) {
            return 0;
        }
        if (start >= 64) {
            return 0;
        }
        
        // Calculate actual length
        int32:actual_len = len;
        if (start + len > 64) {
            actual_len = 64 - start;
        }
        
        // Shift right to position
        int64:shifted = x >> start;
        
        // Create mask for length
        int64:mask = (1 << actual_len) - 1;
        
        return shifted & mask;
    };
    
    // Check if power of 2
    func:is_power_of_2_int64 = *int8(int64:x) {
        if (x == 0) {
            return 0;
        }
        
        int64:res = x & (x - 1);
        if (res == 0) {
            return 1;
        }
        return 0;
    };
    
    // Round up to next power of 2
    func:next_power_of_2_int64 = *int64(int64:x) {
        if (x == 0) {
            return 1;
        }
        
        // Check if already power of 2
        int8:is_pow2 = is_power_of_2_int64(x) ? 0;
        if (is_pow2 == 1) {
            return x;
        }
        
        int64:val = x - 1;
        int32:i = 1;
        
        while (i < 64) {
            val = val | (val >> i);
            i = i * 2;
        }
        
        return val + 1;
    };
    
    // Parity (1 if odd number of set bits, 0 if even)
    func:parity_int64 = *int8(int64:x) {
        int32:count = popcount_int64(x) ? 0;
        return count & 1;
    };


    // Count number of set bits (population count / Hamming weight)
    func:popcount_uint8 = *int32(uint8:x) {
        int32:count = 0;
        uint8:val = x;
        int32:i = 0;
        
        while (i < 8) {
            if ((val & 1) != 0) {
                count = count + 1;
            }
            val = val >> 1;
            i = i + 1;
        }
        
        return count;
    };
    
    // Count leading zeros (CLZ)
    func:clz_uint8 = *int32(uint8:x) {
        if (x == 0) {
            return 8;
        }
        
        int32:count = 0;
        uint8:mask = 1 << (8 - 1);
        
        while ((x & mask) == 0) {
            count = count + 1;
            mask = mask >> 1;
        }
        
        return count;
    };
    
    // Count trailing zeros (CTZ)
    func:ctz_uint8 = *int32(uint8:x) {
        if (x == 0) {
            return 8;
        }
        
        int32:count = 0;
        uint8:val = x;
        
        while ((val & 1) == 0) {
            count = count + 1;
            val = val >> 1;
        }
        
        return count;
    };
    
    // Find first set bit (1-indexed, 0 if none)
    func:ffs_uint8 = *int32(uint8:x) {
        if (x == 0) {
            return 0;
        }
        
        int32:pos = ctz_uint8(x) ? 0;
        return pos + 1;
    };
    
    // Find last set bit (1-indexed, 0 if none)
    func:fls_uint8 = *int32(uint8:x) {
        if (x == 0) {
            return 0;
        }
        
        int32:lz = clz_uint8(x) ? 0;
        return 8 - lz;
    };
    
    // Reverse bits
    func:reverse_bits_uint8 = *uint8(uint8:x) {
        uint8:rev = 0;
        uint8:val = x;
        int32:i = 0;
        
        while (i < 8) {
            rev = rev << 1;
            rev = rev | (val & 1);
            val = val >> 1;
            i = i + 1;
        }
        
        return rev;
    };
    
    // Rotate left
    func:rotl_uint8 = *uint8(uint8:x, int32:n) {
        int32:shift = n % 8;
        if (shift == 0) {
            return x;
        }
        
        uint8:left = x << shift;
        uint8:right = x >> (8 - shift);
        return left | right;
    };
    
    // Rotate right
    func:rotr_uint8 = *uint8(uint8:x, int32:n) {
        int32:shift = n % 8;
        if (shift == 0) {
            return x;
        }
        
        uint8:right = x >> shift;
        uint8:left = x << (8 - shift);
        return right | left;
    };
    
    // Check if bit at position is set
    func:bit_test_uint8 = *int8(uint8:x, int32:pos) {
        if (pos < 0) {
            return 0;
        }
        if (pos >= 8) {
            return 0;
        }
        
        uint8:mask = 1 << pos;
        if ((x & mask) != 0) {
            return 1;
        }
        return 0;
    };
    
    // Set bit at position
    func:bit_set_uint8 = *uint8(uint8:x, int32:pos) {
        if (pos < 0) {
            return x;
        }
        if (pos >= 8) {
            return x;
        }
        
        uint8:mask = 1 << pos;
        return x | mask;
    };
    
    // Clear bit at position
    func:bit_clear_uint8 = *uint8(uint8:x, int32:pos) {
        if (pos < 0) {
            return x;
        }
        if (pos >= 8) {
            return x;
        }
        
        uint8:mask = 1 << pos;
        return x & (~mask);
    };
    
    // Toggle bit at position
    func:bit_toggle_uint8 = *uint8(uint8:x, int32:pos) {
        if (pos < 0) {
            return x;
        }
        if (pos >= 8) {
            return x;
        }
        
        uint8:mask = 1 << pos;
        return x ^ mask;
    };
    
    // Extract bits from range [start, end)
    func:bit_extract_uint8 = *uint8(uint8:x, int32:start, int32:len) {
        if (start < 0) {
            return 0;
        }
        if (len <= 0) {
            return 0;
        }
        if (start >= 8) {
            return 0;
        }
        
        // Calculate actual length
        int32:actual_len = len;
        if (start + len > 8) {
            actual_len = 8 - start;
        }
        
        // Shift right to position
        uint8:shifted = x >> start;
        
        // Create mask for length
        uint8:mask = (1 << actual_len) - 1;
        
        return shifted & mask;
    };
    
    // Check if power of 2
    func:is_power_of_2_uint8 = *int8(uint8:x) {
        if (x == 0) {
            return 0;
        }
        
        uint8:res = x & (x - 1);
        if (res == 0) {
            return 1;
        }
        return 0;
    };
    
    // Round up to next power of 2
    func:next_power_of_2_uint8 = *uint8(uint8:x) {
        if (x == 0) {
            return 1;
        }
        
        // Check if already power of 2
        int8:is_pow2 = is_power_of_2_uint8(x) ? 0;
        if (is_pow2 == 1) {
            return x;
        }
        
        uint8:val = x - 1;
        int32:i = 1;
        
        while (i < 8) {
            val = val | (val >> i);
            i = i * 2;
        }
        
        return val + 1;
    };
    
    // Parity (1 if odd number of set bits, 0 if even)
    func:parity_uint8 = *int8(uint8:x) {
        int32:count = popcount_uint8(x) ? 0;
        return count & 1;
    };


    // Count number of set bits (population count / Hamming weight)
    func:popcount_uint16 = *int32(uint16:x) {
        int32:count = 0;
        uint16:val = x;
        int32:i = 0;
        
        while (i < 16) {
            if ((val & 1) != 0) {
                count = count + 1;
            }
            val = val >> 1;
            i = i + 1;
        }
        
        return count;
    };
    
    // Count leading zeros (CLZ)
    func:clz_uint16 = *int32(uint16:x) {
        if (x == 0) {
            return 16;
        }
        
        int32:count = 0;
        uint16:mask = 1 << (16 - 1);
        
        while ((x & mask) == 0) {
            count = count + 1;
            mask = mask >> 1;
        }
        
        return count;
    };
    
    // Count trailing zeros (CTZ)
    func:ctz_uint16 = *int32(uint16:x) {
        if (x == 0) {
            return 16;
        }
        
        int32:count = 0;
        uint16:val = x;
        
        while ((val & 1) == 0) {
            count = count + 1;
            val = val >> 1;
        }
        
        return count;
    };
    
    // Find first set bit (1-indexed, 0 if none)
    func:ffs_uint16 = *int32(uint16:x) {
        if (x == 0) {
            return 0;
        }
        
        int32:pos = ctz_uint16(x) ? 0;
        return pos + 1;
    };
    
    // Find last set bit (1-indexed, 0 if none)
    func:fls_uint16 = *int32(uint16:x) {
        if (x == 0) {
            return 0;
        }
        
        int32:lz = clz_uint16(x) ? 0;
        return 16 - lz;
    };
    
    // Reverse bits
    func:reverse_bits_uint16 = *uint16(uint16:x) {
        uint16:rev = 0;
        uint16:val = x;
        int32:i = 0;
        
        while (i < 16) {
            rev = rev << 1;
            rev = rev | (val & 1);
            val = val >> 1;
            i = i + 1;
        }
        
        return rev;
    };
    
    // Rotate left
    func:rotl_uint16 = *uint16(uint16:x, int32:n) {
        int32:shift = n % 16;
        if (shift == 0) {
            return x;
        }
        
        uint16:left = x << shift;
        uint16:right = x >> (16 - shift);
        return left | right;
    };
    
    // Rotate right
    func:rotr_uint16 = *uint16(uint16:x, int32:n) {
        int32:shift = n % 16;
        if (shift == 0) {
            return x;
        }
        
        uint16:right = x >> shift;
        uint16:left = x << (16 - shift);
        return right | left;
    };
    
    // Check if bit at position is set
    func:bit_test_uint16 = *int8(uint16:x, int32:pos) {
        if (pos < 0) {
            return 0;
        }
        if (pos >= 16) {
            return 0;
        }
        
        uint16:mask = 1 << pos;
        if ((x & mask) != 0) {
            return 1;
        }
        return 0;
    };
    
    // Set bit at position
    func:bit_set_uint16 = *uint16(uint16:x, int32:pos) {
        if (pos < 0) {
            return x;
        }
        if (pos >= 16) {
            return x;
        }
        
        uint16:mask = 1 << pos;
        return x | mask;
    };
    
    // Clear bit at position
    func:bit_clear_uint16 = *uint16(uint16:x, int32:pos) {
        if (pos < 0) {
            return x;
        }
        if (pos >= 16) {
            return x;
        }
        
        uint16:mask = 1 << pos;
        return x & (~mask);
    };
    
    // Toggle bit at position
    func:bit_toggle_uint16 = *uint16(uint16:x, int32:pos) {
        if (pos < 0) {
            return x;
        }
        if (pos >= 16) {
            return x;
        }
        
        uint16:mask = 1 << pos;
        return x ^ mask;
    };
    
    // Extract bits from range [start, end)
    func:bit_extract_uint16 = *uint16(uint16:x, int32:start, int32:len) {
        if (start < 0) {
            return 0;
        }
        if (len <= 0) {
            return 0;
        }
        if (start >= 16) {
            return 0;
        }
        
        // Calculate actual length
        int32:actual_len = len;
        if (start + len > 16) {
            actual_len = 16 - start;
        }
        
        // Shift right to position
        uint16:shifted = x >> start;
        
        // Create mask for length
        uint16:mask = (1 << actual_len) - 1;
        
        return shifted & mask;
    };
    
    // Check if power of 2
    func:is_power_of_2_uint16 = *int8(uint16:x) {
        if (x == 0) {
            return 0;
        }
        
        uint16:res = x & (x - 1);
        if (res == 0) {
            return 1;
        }
        return 0;
    };
    
    // Round up to next power of 2
    func:next_power_of_2_uint16 = *uint16(uint16:x) {
        if (x == 0) {
            return 1;
        }
        
        // Check if already power of 2
        int8:is_pow2 = is_power_of_2_uint16(x) ? 0;
        if (is_pow2 == 1) {
            return x;
        }
        
        uint16:val = x - 1;
        int32:i = 1;
        
        while (i < 16) {
            val = val | (val >> i);
            i = i * 2;
        }
        
        return val + 1;
    };
    
    // Parity (1 if odd number of set bits, 0 if even)
    func:parity_uint16 = *int8(uint16:x) {
        int32:count = popcount_uint16(x) ? 0;
        return count & 1;
    };


    // Count number of set bits (population count / Hamming weight)
    func:popcount_uint32 = *int32(uint32:x) {
        int32:count = 0;
        uint32:val = x;
        int32:i = 0;
        
        while (i < 32) {
            if ((val & 1) != 0) {
                count = count + 1;
            }
            val = val >> 1;
            i = i + 1;
        }
        
        return count;
    };
    
    // Count leading zeros (CLZ)
    func:clz_uint32 = *int32(uint32:x) {
        if (x == 0) {
            return 32;
        }
        
        int32:count = 0;
        uint32:mask = 1 << (32 - 1);
        
        while ((x & mask) == 0) {
            count = count + 1;
            mask = mask >> 1;
        }
        
        return count;
    };
    
    // Count trailing zeros (CTZ)
    func:ctz_uint32 = *int32(uint32:x) {
        if (x == 0) {
            return 32;
        }
        
        int32:count = 0;
        uint32:val = x;
        
        while ((val & 1) == 0) {
            count = count + 1;
            val = val >> 1;
        }
        
        return count;
    };
    
    // Find first set bit (1-indexed, 0 if none)
    func:ffs_uint32 = *int32(uint32:x) {
        if (x == 0) {
            return 0;
        }
        
        int32:pos = ctz_uint32(x) ? 0;
        return pos + 1;
    };
    
    // Find last set bit (1-indexed, 0 if none)
    func:fls_uint32 = *int32(uint32:x) {
        if (x == 0) {
            return 0;
        }
        
        int32:lz = clz_uint32(x) ? 0;
        return 32 - lz;
    };
    
    // Reverse bits
    func:reverse_bits_uint32 = *uint32(uint32:x) {
        uint32:rev = 0;
        uint32:val = x;
        int32:i = 0;
        
        while (i < 32) {
            rev = rev << 1;
            rev = rev | (val & 1);
            val = val >> 1;
            i = i + 1;
        }
        
        return rev;
    };
    
    // Rotate left
    func:rotl_uint32 = *uint32(uint32:x, int32:n) {
        int32:shift = n % 32;
        if (shift == 0) {
            return x;
        }
        
        uint32:left = x << shift;
        uint32:right = x >> (32 - shift);
        return left | right;
    };
    
    // Rotate right
    func:rotr_uint32 = *uint32(uint32:x, int32:n) {
        int32:shift = n % 32;
        if (shift == 0) {
            return x;
        }
        
        uint32:right = x >> shift;
        uint32:left = x << (32 - shift);
        return right | left;
    };
    
    // Check if bit at position is set
    func:bit_test_uint32 = *int8(uint32:x, int32:pos) {
        if (pos < 0) {
            return 0;
        }
        if (pos >= 32) {
            return 0;
        }
        
        uint32:mask = 1 << pos;
        if ((x & mask) != 0) {
            return 1;
        }
        return 0;
    };
    
    // Set bit at position
    func:bit_set_uint32 = *uint32(uint32:x, int32:pos) {
        if (pos < 0) {
            return x;
        }
        if (pos >= 32) {
            return x;
        }
        
        uint32:mask = 1 << pos;
        return x | mask;
    };
    
    // Clear bit at position
    func:bit_clear_uint32 = *uint32(uint32:x, int32:pos) {
        if (pos < 0) {
            return x;
        }
        if (pos >= 32) {
            return x;
        }
        
        uint32:mask = 1 << pos;
        return x & (~mask);
    };
    
    // Toggle bit at position
    func:bit_toggle_uint32 = *uint32(uint32:x, int32:pos) {
        if (pos < 0) {
            return x;
        }
        if (pos >= 32) {
            return x;
        }
        
        uint32:mask = 1 << pos;
        return x ^ mask;
    };
    
    // Extract bits from range [start, end)
    func:bit_extract_uint32 = *uint32(uint32:x, int32:start, int32:len) {
        if (start < 0) {
            return 0;
        }
        if (len <= 0) {
            return 0;
        }
        if (start >= 32) {
            return 0;
        }
        
        // Calculate actual length
        int32:actual_len = len;
        if (start + len > 32) {
            actual_len = 32 - start;
        }
        
        // Shift right to position
        uint32:shifted = x >> start;
        
        // Create mask for length
        uint32:mask = (1 << actual_len) - 1;
        
        return shifted & mask;
    };
    
    // Check if power of 2
    func:is_power_of_2_uint32 = *int8(uint32:x) {
        if (x == 0) {
            return 0;
        }
        
        uint32:res = x & (x - 1);
        if (res == 0) {
            return 1;
        }
        return 0;
    };
    
    // Round up to next power of 2
    func:next_power_of_2_uint32 = *uint32(uint32:x) {
        if (x == 0) {
            return 1;
        }
        
        // Check if already power of 2
        int8:is_pow2 = is_power_of_2_uint32(x) ? 0;
        if (is_pow2 == 1) {
            return x;
        }
        
        uint32:val = x - 1;
        int32:i = 1;
        
        while (i < 32) {
            val = val | (val >> i);
            i = i * 2;
        }
        
        return val + 1;
    };
    
    // Parity (1 if odd number of set bits, 0 if even)
    func:parity_uint32 = *int8(uint32:x) {
        int32:count = popcount_uint32(x) ? 0;
        return count & 1;
    };


    // Count number of set bits (population count / Hamming weight)
    func:popcount_uint64 = *int32(uint64:x) {
        int32:count = 0;
        uint64:val = x;
        int32:i = 0;
        
        while (i < 64) {
            if ((val & 1) != 0) {
                count = count + 1;
            }
            val = val >> 1;
            i = i + 1;
        }
        
        return count;
    };
    
    // Count leading zeros (CLZ)
    func:clz_uint64 = *int32(uint64:x) {
        if (x == 0) {
            return 64;
        }
        
        int32:count = 0;
        uint64:mask = 1 << (64 - 1);
        
        while ((x & mask) == 0) {
            count = count + 1;
            mask = mask >> 1;
        }
        
        return count;
    };
    
    // Count trailing zeros (CTZ)
    func:ctz_uint64 = *int32(uint64:x) {
        if (x == 0) {
            return 64;
        }
        
        int32:count = 0;
        uint64:val = x;
        
        while ((val & 1) == 0) {
            count = count + 1;
            val = val >> 1;
        }
        
        return count;
    };
    
    // Find first set bit (1-indexed, 0 if none)
    func:ffs_uint64 = *int32(uint64:x) {
        if (x == 0) {
            return 0;
        }
        
        int32:pos = ctz_uint64(x) ? 0;
        return pos + 1;
    };
    
    // Find last set bit (1-indexed, 0 if none)
    func:fls_uint64 = *int32(uint64:x) {
        if (x == 0) {
            return 0;
        }
        
        int32:lz = clz_uint64(x) ? 0;
        return 64 - lz;
    };
    
    // Reverse bits
    func:reverse_bits_uint64 = *uint64(uint64:x) {
        uint64:rev = 0;
        uint64:val = x;
        int32:i = 0;
        
        while (i < 64) {
            rev = rev << 1;
            rev = rev | (val & 1);
            val = val >> 1;
            i = i + 1;
        }
        
        return rev;
    };
    
    // Rotate left
    func:rotl_uint64 = *uint64(uint64:x, int32:n) {
        int32:shift = n % 64;
        if (shift == 0) {
            return x;
        }
        
        uint64:left = x << shift;
        uint64:right = x >> (64 - shift);
        return left | right;
    };
    
    // Rotate right
    func:rotr_uint64 = *uint64(uint64:x, int32:n) {
        int32:shift = n % 64;
        if (shift == 0) {
            return x;
        }
        
        uint64:right = x >> shift;
        uint64:left = x << (64 - shift);
        return right | left;
    };
    
    // Check if bit at position is set
    func:bit_test_uint64 = *int8(uint64:x, int32:pos) {
        if (pos < 0) {
            return 0;
        }
        if (pos >= 64) {
            return 0;
        }
        
        uint64:mask = 1 << pos;
        if ((x & mask) != 0) {
            return 1;
        }
        return 0;
    };
    
    // Set bit at position
    func:bit_set_uint64 = *uint64(uint64:x, int32:pos) {
        if (pos < 0) {
            return x;
        }
        if (pos >= 64) {
            return x;
        }
        
        uint64:mask = 1 << pos;
        return x | mask;
    };
    
    // Clear bit at position
    func:bit_clear_uint64 = *uint64(uint64:x, int32:pos) {
        if (pos < 0) {
            return x;
        }
        if (pos >= 64) {
            return x;
        }
        
        uint64:mask = 1 << pos;
        return x & (~mask);
    };
    
    // Toggle bit at position
    func:bit_toggle_uint64 = *uint64(uint64:x, int32:pos) {
        if (pos < 0) {
            return x;
        }
        if (pos >= 64) {
            return x;
        }
        
        uint64:mask = 1 << pos;
        return x ^ mask;
    };
    
    // Extract bits from range [start, end)
    func:bit_extract_uint64 = *uint64(uint64:x, int32:start, int32:len) {
        if (start < 0) {
            return 0;
        }
        if (len <= 0) {
            return 0;
        }
        if (start >= 64) {
            return 0;
        }
        
        // Calculate actual length
        int32:actual_len = len;
        if (start + len > 64) {
            actual_len = 64 - start;
        }
        
        // Shift right to position
        uint64:shifted = x >> start;
        
        // Create mask for length
        uint64:mask = (1 << actual_len) - 1;
        
        return shifted & mask;
    };
    
    // Check if power of 2
    func:is_power_of_2_uint64 = *int8(uint64:x) {
        if (x == 0) {
            return 0;
        }
        
        uint64:res = x & (x - 1);
        if (res == 0) {
            return 1;
        }
        return 0;
    };
    
    // Round up to next power of 2
    func:next_power_of_2_uint64 = *uint64(uint64:x) {
        if (x == 0) {
            return 1;
        }
        
        // Check if already power of 2
        int8:is_pow2 = is_power_of_2_uint64(x) ? 0;
        if (is_pow2 == 1) {
            return x;
        }
        
        uint64:val = x - 1;
        int32:i = 1;
        
        while (i < 64) {
            val = val | (val >> i);
            i = i * 2;
        }
        
        return val + 1;
    };
    
    // Parity (1 if odd number of set bits, 0 if even)
    func:parity_uint64 = *int8(uint64:x) {
        int32:count = popcount_uint64(x) ? 0;
        return count & 1;
    };


// ============================================================================
// BIT MANIPULATION SUMMARY
// ============================================================================
// Generated Functions (17 functions Ã— 8 types = 136 total):
//
// 1. popcount_T(x) - Count set bits (population count)
// 2. clz_T(x) - Count leading zeros
// 3. ctz_T(x) - Count trailing zeros
// 4. ffs_T(x) - Find first set bit (1-indexed)
// 5. fls_T(x) - Find last set bit (1-indexed)
// 6. reverse_bits_T(x) - Reverse all bits
// 7. rotl_T(x, n) - Rotate left by n positions
// 8. rotr_T(x, n) - Rotate right by n positions
// 9. bit_test_T(x, pos) - Test if bit at position is set
// 10. bit_set_T(x, pos) - Set bit at position
// 11. bit_clear_T(x, pos) - Clear bit at position
// 12. bit_toggle_T(x, pos) - Toggle bit at position
// 13. bit_extract_T(x, start, len) - Extract bit range
// 14. is_power_of_2_T(x) - Check if power of 2
// 15. next_power_of_2_T(x) - Round up to next power of 2
// 16. parity_T(x) - Calculate parity bit
//
// Types: int8, int16, int32, int64, uint8, uint16, uint32, uint64
// ============================================================================

func:main = *int8() {
    puts("ğŸ‰ Bit Operations Library: 136 functions compiled successfully!");
    return 0;
};
